I"°<ul id="markdown-toc">
  <li><a href="#å‰è¨€" id="markdown-toc-å‰è¨€">å‰è¨€</a></li>
  <li><a href="#å‚è€ƒ" id="markdown-toc-å‚è€ƒ">å‚è€ƒ</a></li>
</ul>
<hr />

<h1 id="å‰è¨€">å‰è¨€</h1>

<p>åœ¨Swift3.1ä¸­ä½¿ç”¨<code class="language-plaintext highlighter-rouge">initialize</code>ä¼šå‡ºç°å¦‚ä¸‹è­¦å‘Šï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Method 'initialize()' defines Objective-C class method 'initialize', which is not guaranteed to be invoked by Swift and will be disallowed in future versionsã€‚
</code></pre></div></div>

<p>ä»¥ä¸‹æ˜¯å›½å¤–è®ºå›ä¸Šçš„ä¸€ç§æ–¹æ¡ˆï¼š</p>

<p>1.</p>

<p>Define the following Swift code. The purpose is to provide a simple entry point for any class that you would like to imbue with behaviour akin to initialize() - this can now be done simply by conforming to SelfAware. It also provides a single function to run this behaviour for every conforming class.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// å®šä¹‰ `protocol`
public protocol SelfAware: class {
    static func awake()
}

// åˆ›å»ºä»£ç†æ‰§è¡Œå•ä¾‹
class NothingToSeeHere{

    static func harmlessFunction(){
        let typeCount = Int(objc_getClassList(nil, 0))
        let  types = UnsafeMutablePointer&lt;AnyClass?&gt;.allocate(capacity: typeCount)
        let autoreleaseintTypes = AutoreleasingUnsafeMutablePointer&lt;AnyClass?&gt;(types)
        objc_getClassList(autoreleaseintTypes, Int32(typeCount)) //è·å–æ‰€æœ‰çš„ç±»
        for index in 0 ..&lt; typeCount{
            (types[index] as? SelfAware.Type)?.awake() //å¦‚æœè¯¥ç±»å®ç°äº†SelfAwareåè®®ï¼Œé‚£ä¹ˆè°ƒç”¨awakeæ–¹æ³•
        }
        types.deallocate(capacity: typeCount)
    }
}
</code></pre></div></div>

<p>2.</p>

<p>Thatâ€™s all good and well, but we still need a way to actually run the function we defined, i.e. NothingToSeeHere.harmlessFunction(), on application start up. Previously, this answer suggested using Objective-C code to do this. However, it seems that we can do what we need using only Swift. For macOS or other platforms where UIApplication is not available, a variation of the following will be needed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// æ‰§è¡Œå•ä¾‹
extension UIApplication {
    private static let runOnce:Void = {
        //ä½¿ç”¨é™æ€å±æ€§ä»¥ä¿è¯åªè°ƒç”¨ä¸€æ¬¡(è¯¥å±æ€§æ˜¯ä¸ªæ–¹æ³•)
        NothingToSeeHere.harmlessFunction()
        UIButton.harmlessFunction()
    }()

    open override var next: UIResponder?{
        UIApplication.runOnce
        return super.next
    }
}
</code></pre></div></div>

<p>3.</p>

<p>We now have an entry point at application start up, and a way to hook into this from classes of your choice. All that is left to do: instead of implementing initialize(), conform to SelfAware and implement the defined method, awake().</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// å°†ç±»è®¾ç½®ä¸ºä»£ç†å¹¶åœ¨ä»£ç†ä¸­å®ç°è¿è¡Œæ—¶ä»£å—
extension UIButton:SelfAware{
    public static func awake() {
        
    }
}
</code></pre></div></div>

<h1 id="å‚è€ƒ">å‚è€ƒ</h1>

<ul>
  <li><a href="https://stackoverflow.com/questions/42824541/swift-3-1-deprecates-initialize-how-can-i-achieve-the-same-thing">Swift 3.1 deprecates initialize(). How can I achieve the same thing?</a></li>
</ul>
:ET