I"»b<ul id="markdown-toc">
  <li><a href="#ç»“æ„" id="markdown-toc-ç»“æ„">ç»“æ„</a></li>
  <li><a href="#æºç åˆ†æ" id="markdown-toc-æºç åˆ†æ">æºç åˆ†æ</a>    <ul>
      <li><a href="#fbshimmeringh" id="markdown-toc-fbshimmeringh">FBShimmering.h</a></li>
      <li><a href="#fbshimmeringview" id="markdown-toc-fbshimmeringview">FBShimmeringView</a></li>
      <li><a href="#fbshimmeringlayer" id="markdown-toc-fbshimmeringlayer">FBShimmeringLayer</a></li>
    </ul>
  </li>
</ul>
<hr />

<h1 id="ç»“æ„">ç»“æ„</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FBShimmering
â”œâ”€â”€ FBShimmering-Prefix.pch
â”œâ”€â”€ FBShimmering.h
â”œâ”€â”€ FBShimmeringLayer.h
â”œâ”€â”€ FBShimmeringLayer.m
â”œâ”€â”€ FBShimmeringView.h
â””â”€â”€ FBShimmeringView.m
</code></pre></div></div>

<p><em><code class="language-plaintext highlighter-rouge">FBShimmering</code></em>   // ä¸€ä¸ªåè®®ï¼Œä¸»è¦å°è£…äº†ä¸€äº›å¸¸ç”¨çš„å±æ€§ã€‚</p>

<p><em><code class="language-plaintext highlighter-rouge">FBShimmeringView</code></em>  // å®ç°äº†<code class="language-plaintext highlighter-rouge">FBShimmering</code> åè®®ï¼Œä¸»è¦æ˜¯ä¿®æ”¹å…¶å›¾å±‚<code class="language-plaintext highlighter-rouge">FBShimmeringLayer</code>ï¼Œå¯¹å¤–æä¾›äº†<code class="language-plaintext highlighter-rouge">contentView</code>ã€‚</p>

<p><em><code class="language-plaintext highlighter-rouge">FBShimmeringLayer</code></em>  // å®ç°äº†<code class="language-plaintext highlighter-rouge">FBShimmering</code> åè®®ï¼Œæ˜¯å®ç°æ•´ä¸ªåŠ¨ç”»æ•ˆæœçš„æ ¸å¿ƒéƒ¨åˆ†ã€‚åŒ…å«äº†ä¸¤ä¸ª<code class="language-plaintext highlighter-rouge">layer</code>ï¼Œä¸€ä¸ªæ˜¯åŒ…å«å†…å®¹çš„<code class="language-plaintext highlighter-rouge">contentLayer</code>ï¼Œå¦ä¸€ä¸ªä¾¿æ˜¯ç”¨æˆ·è’™å±‚é—ªå…‰æ•ˆæœçš„<code class="language-plaintext highlighter-rouge">maskLayer</code>ã€‚</p>

<h1 id="æºç åˆ†æ">æºç åˆ†æ</h1>

<h2 id="fbshimmeringh">FBShimmering.h</h2>

<pre><code class="language-objective-c">/**
 Copyright (c) 2014-present, Facebook, Inc.
 All rights reserved.
 
 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree. An additional grant
 of patent rights can be found in the PATENTS file in the same directory.
 */

#import &lt;CoreGraphics/CoreGraphics.h&gt;
#import &lt;Foundation/Foundation.h&gt;

typedef NS_ENUM(NSInteger, FBShimmerDirection) {
  //! Shimmer animation goes from left to right
  FBShimmerDirectionRight,
  //! Shimmer animation goes from right to left
  FBShimmerDirectionLeft,
  //! Shimmer animation goes from below to above
  FBShimmerDirectionUp,
  //! Shimmer animation goes from above to below
  FBShimmerDirectionDown,
};

static const float FBShimmerDefaultBeginTime = CGFLOAT_MAX;

@protocol FBShimmering &lt;NSObject&gt;

//! @abstract Set this to YES to start shimming and NO to stop. Defaults to NO.
@property (assign, nonatomic, readwrite, getter = isShimmering) BOOL shimmering;

//! @abstract The time interval between shimmerings in seconds. Defaults to 0.4.
@property (assign, nonatomic, readwrite) CFTimeInterval shimmeringPauseDuration;

//! @abstract The opacity of the content while it is shimmering. Defaults to 0.5.
@property (assign, nonatomic, readwrite) CGFloat shimmeringAnimationOpacity;

//! @abstract The opacity of the content before it is shimmering. Defaults to 1.0.
@property (assign, nonatomic, readwrite) CGFloat shimmeringOpacity;

//! @abstract The speed of shimmering, in points per second. Defaults to 230.
@property (assign, nonatomic, readwrite) CGFloat shimmeringSpeed;

//! @abstract The highlight length of shimmering. Range of [0,1], defaults to 1.0.
@property (assign, nonatomic, readwrite) CGFloat shimmeringHighlightLength;

//! @abstract Same as "shimmeringHighlightLength", just for downward compatibility. @deprecated
@property (assign, nonatomic, readwrite, getter = shimmeringHighlightLength, setter = setShimmeringHighlightLength:) CGFloat shimmeringHighlightWidth DEPRECATED_MSG_ATTRIBUTE("Use shimmeringHighlightLength");

//! @abstract The direction of shimmering animation. Defaults to FBShimmerDirectionRight.
@property (assign, nonatomic, readwrite) FBShimmerDirection shimmeringDirection;

//! @abstract The duration of the fade used when shimmer begins. Defaults to 0.1.
@property (assign, nonatomic, readwrite) CFTimeInterval shimmeringBeginFadeDuration;

//! @abstract The duration of the fade used when shimmer ends. Defaults to 0.3.
@property (assign, nonatomic, readwrite) CFTimeInterval shimmeringEndFadeDuration;

/**
 @abstract The absolute CoreAnimation media time when the shimmer will fade in.
 @discussion Only valid after setting {@ref shimmering} to NO.
 */
@property (assign, nonatomic, readonly) CFTimeInterval shimmeringFadeTime;

/**
 @abstract The absolute CoreAnimation media time when the shimmer will begin.
 @discussion Only valid after setting {@ref shimmering} to YES.
 */
@property (assign, nonatomic) CFTimeInterval shimmeringBeginTime;

@end


</code></pre>

<h2 id="fbshimmeringview">FBShimmeringView</h2>

<pre><code class="language-objective-c">/**
 Copyright (c) 2014-present, Facebook, Inc.
 All rights reserved.
 
 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree. An additional grant
 of patent rights can be found in the PATENTS file in the same directory.
 */

#import &lt;UIKit/UIView.h&gt;

#import "FBShimmering.h"

/**
  @abstract Lightweight, generic shimmering view.
 */
@interface FBShimmeringView : UIView &lt;FBShimmering&gt;

//! @abstract The content view to be shimmered.
@property (strong, nonatomic) UIView *contentView;

@end

</code></pre>

<pre><code class="language-objective-c">/**
 Copyright (c) 2014-present, Facebook, Inc.
 All rights reserved.
 
 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree. An additional grant
 of patent rights can be found in the PATENTS file in the same directory.
 */

#import "FBShimmeringView.h"

#import "FBShimmeringLayer.h"

#if !__has_feature(objc_arc)
#error This file must be compiled with ARC. Convert your project to ARC or specify the -fobjc-arc flag.
#endif

@implementation FBShimmeringView

/*
é€šè¿‡å®ç° layerClassæ–¹æ³•æ¥ä¿®æ”¹ FBShimmeringView çš„å…³è”å›¾å±‚ï¼Œå¯¹FBShimmeringViewçš„æ“ä½œå°±ä¼šç”±FBShimmeringLayeræ¥å®ç°ã€‚
*/
+ (Class)layerClass
{
  return [FBShimmeringLayer class];
}

/*
ä»¥ä¸‹æ˜¯é€šè¿‡å®å®šä¹‰çš„æ–¹å¼å®ç° FBShimmering åè®®å±æ€§çš„ Get å’Œ Set æ–¹æ³•ã€‚
*/

#define __layer ((FBShimmeringLayer *)self.layer)

#define LAYER_ACCESSOR(accessor, ctype) \
- (ctype)accessor { \
  return [__layer accessor]; \
}

#define LAYER_MUTATOR(mutator, ctype) \
- (void)mutator (ctype)value { \
  [__layer mutator value]; \
}

#define LAYER_RW_PROPERTY(accessor, mutator, ctype) \
  LAYER_ACCESSOR (accessor, ctype) \
  LAYER_MUTATOR (mutator, ctype)

LAYER_RW_PROPERTY(isShimmering, setShimmering:, BOOL)
LAYER_RW_PROPERTY(shimmeringPauseDuration, setShimmeringPauseDuration:, CFTimeInterval)
LAYER_RW_PROPERTY(shimmeringAnimationOpacity, setShimmeringAnimationOpacity:, CGFloat)
LAYER_RW_PROPERTY(shimmeringOpacity, setShimmeringOpacity:, CGFloat)
LAYER_RW_PROPERTY(shimmeringSpeed, setShimmeringSpeed:, CGFloat)
LAYER_RW_PROPERTY(shimmeringHighlightLength, setShimmeringHighlightLength:, CGFloat)
LAYER_RW_PROPERTY(shimmeringDirection, setShimmeringDirection:, FBShimmerDirection)
LAYER_ACCESSOR(shimmeringFadeTime, CFTimeInterval)
LAYER_RW_PROPERTY(shimmeringBeginFadeDuration, setShimmeringBeginFadeDuration:, CFTimeInterval)
LAYER_RW_PROPERTY(shimmeringEndFadeDuration, setShimmeringEndFadeDuration:, CFTimeInterval)
LAYER_RW_PROPERTY(shimmeringBeginTime, setShimmeringBeginTime:, CFTimeInterval)

- (void)setContentView:(UIView *)contentView
{
  if (contentView != _contentView) {
    _contentView = contentView;
    [self addSubview:contentView];
    __layer.contentLayer = contentView.layer;
  }
}

- (void)layoutSubviews
{
  // Autolayout requires these to be set on the UIView, not the CALayer.
  // Do this *before* the layer has a chance to set the properties, as the
  // setters would be ignored (even for autolayout) if set to the same value.
  _contentView.bounds = self.bounds;
  _contentView.center = self.center;

  [super layoutSubviews];
}

@end

</code></pre>

<h2 id="fbshimmeringlayer">FBShimmeringLayer</h2>

<pre><code class="language-objective-c">/**
 Copyright (c) 2014-present, Facebook, Inc.
 All rights reserved.
 
 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree. An additional grant
 of patent rights can be found in the PATENTS file in the same directory.
 */

#import &lt;QuartzCore/CALayer.h&gt;

#import "FBShimmering.h"

/**
  @abstract Lightweight, generic shimmering layer.
 */
@interface FBShimmeringLayer : CALayer &lt;FBShimmering&gt;

//! @abstract The content layer to be shimmered.
@property (strong, nonatomic) CALayer *contentLayer;

@end

</code></pre>

<pre><code class="language-objective-c">/**
 Copyright (c) 2014-present, Facebook, Inc.
 All rights reserved.
 
 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree. An additional grant
 of patent rights can be found in the PATENTS file in the same directory.
 */

#import "FBShimmeringLayer.h"

#import &lt;QuartzCore/CAAnimation.h&gt;
#import &lt;QuartzCore/CAGradientLayer.h&gt;
#import &lt;QuartzCore/CATransaction.h&gt;

#import &lt;UIKit/UIGeometry.h&gt;
#import &lt;UIKit/UIColor.h&gt;

#if !__has_feature(objc_arc)
#error This file must be compiled with ARC. Convert your project to ARC or specify the -fobjc-arc flag.
#endif


/*
è¿™é‡Œåˆ¤æ–­äº†æ˜¯å¦æ˜¯æ¨¡æ‹Ÿå™¨ã€‚
å¼•ç”¨äº† UIKit çš„ç§æœ‰æ–¹æ³• UIAnimationDragCoefficientã€‚
è¿™é‡Œå…ˆé€šè¿‡UIKIT_EXTERNçš„æ–¹å¼å°†å…¶å¼•å…¥è¿›æ¥ã€‚è¿”å›ä¸€ä¸ªfloat ç±»å‹çš„å€¼ã€‚è¡¨ç¤ºâ€œæ‹–æ‹½ç³»æ•°â€ï¼Œé»˜è®¤æ˜¯ç­‰äº 1.0 çš„ï¼Œè¿™ä¸ªå€¼å¯¹åº”ç€æ¨¡æ‹Ÿå™¨çš„ â€œSlow Animationsâ€ é€‰é¡¹ï¼Œå½“æˆ‘ä»¬æ‰“å¼€è¿™ä¸ªé€‰é¡¹çš„æ—¶å€™ï¼Œä»–çš„å€¼ä¼šå˜æˆ10ï¼Œå³æ…¢äº†10å€ã€‚
*/
#if TARGET_IPHONE_SIMULATOR
UIKIT_EXTERN float UIAnimationDragCoefficient(void); // UIKit private drag coeffient, use judiciously
#endif

static CGFloat FBShimmeringLayerDragCoefficient(void)
{
#if TARGET_IPHONE_SIMULATOR
  return UIAnimationDragCoefficient();
#else
  return 1.0;
#endif
}

static void FBShimmeringLayerAnimationApplyDragCoefficient(CAAnimation *animation)
{
  CGFloat k = FBShimmeringLayerDragCoefficient();
  
  if (k != 0 &amp;&amp; k != 1) {
    animation.speed = 1 / k;
  }
}

// animations keys
static NSString *const kFBShimmerSlideAnimationKey = @"slide";
static NSString *const kFBFadeAnimationKey = @"fade";
static NSString *const kFBEndFadeAnimationKey = @"fade-end";

static CABasicAnimation *fade_animation(CALayer *layer, CGFloat opacity, CFTimeInterval duration)
{
  CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"opacity"];
  animation.fromValue = @([(layer.presentationLayer ?: layer) opacity]);
  animation.toValue = @(opacity);
  animation.fillMode = kCAFillModeBoth;
  animation.removedOnCompletion = NO;
  animation.duration = duration;
  FBShimmeringLayerAnimationApplyDragCoefficient(animation);
  return animation;
}

static CABasicAnimation *shimmer_slide_animation(CFTimeInterval duration, FBShimmerDirection direction)
{
  CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"position"];
  animation.toValue = [NSValue valueWithCGPoint:CGPointZero];
  animation.duration = duration;
  animation.repeatCount = HUGE_VALF;
  FBShimmeringLayerAnimationApplyDragCoefficient(animation);
  if (direction == FBShimmerDirectionLeft ||
      direction == FBShimmerDirectionUp) {
    animation.speed = -fabsf(animation.speed);
  }
  return animation;
}

// take a shimmer slide animation and turns into repeating
static CAAnimation *shimmer_slide_repeat(CAAnimation *a, CFTimeInterval duration, FBShimmerDirection direction)
{
  CAAnimation *anim = [a copy];
  anim.repeatCount = HUGE_VALF;
  anim.duration = duration;
  anim.speed = (direction == FBShimmerDirectionRight || direction == FBShimmerDirectionDown) ? fabsf(anim.speed) : -fabsf(anim.speed);
  return anim;
}

// take a shimmer slide animation and turns into finish
static CAAnimation *shimmer_slide_finish(CAAnimation *a)
{
  CAAnimation *anim = [a copy];
  anim.repeatCount = 0;
  return anim;
}

@interface FBShimmeringMaskLayer : CAGradientLayer
@property (readonly, nonatomic) CALayer *fadeLayer;
@end

@implementation FBShimmeringMaskLayer

- (instancetype)init
{
  self = [super init];
  if (nil != self) {
    _fadeLayer = [[CALayer alloc] init];
    _fadeLayer.backgroundColor = [UIColor whiteColor].CGColor;
    [self addSublayer:_fadeLayer];
  }
  return self;
}

- (void)layoutSublayers
{
  [super layoutSublayers];
  CGRect r = self.bounds;
  _fadeLayer.bounds = r;
  _fadeLayer.position = CGPointMake(CGRectGetMidX(r), CGRectGetMidY(r));
}

@end

@interface FBShimmeringLayer ()
#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000
// iOS 10 SDK has CALayerDelegate and CAAnimationDelegate as proper protocols.
&lt;CALayerDelegate, CAAnimationDelegate&gt;
#endif

@property (strong, nonatomic) FBShimmeringMaskLayer *maskLayer;
@end

@implementation FBShimmeringLayer
{
  CALayer *_contentLayer;
  FBShimmeringMaskLayer *_maskLayer;
}

#pragma mark - Lifecycle

@synthesize shimmering = _shimmering;
@synthesize shimmeringPauseDuration = _shimmeringPauseDuration;
@synthesize shimmeringAnimationOpacity = _shimmeringAnimationOpacity;
@synthesize shimmeringOpacity = _shimmeringOpacity;
@synthesize shimmeringSpeed = _shimmeringSpeed;
@synthesize shimmeringHighlightLength = _shimmeringHighlightLength;
@synthesize shimmeringDirection = _shimmeringDirection;
@synthesize shimmeringFadeTime = _shimmeringFadeTime;
@synthesize shimmeringBeginFadeDuration = _shimmeringBeginFadeDuration;
@synthesize shimmeringEndFadeDuration = _shimmeringEndFadeDuration;
@synthesize shimmeringBeginTime = _shimmeringBeginTime;
@dynamic shimmeringHighlightWidth;

- (instancetype)init
{
  self = [super init];
  if (nil != self) {
    // é»˜è®¤é…ç½®
    // default configuration
    _shimmeringPauseDuration = 0.4;
    _shimmeringSpeed = 230.0;
    _shimmeringHighlightLength = 1.0;
    _shimmeringAnimationOpacity = 0.5;
    _shimmeringOpacity = 1.0;
    _shimmeringDirection = FBShimmerDirectionRight;
    _shimmeringBeginFadeDuration = 0.1;
    _shimmeringEndFadeDuration = 0.3;
    _shimmeringBeginTime = FBShimmerDefaultBeginTime;
  }
  return self;
}

#pragma mark - Properties

- (void)setContentLayer:(CALayer *)contentLayer
{
  // reset mask
  self.maskLayer = nil;

  // note content layer and add for display
  _contentLayer = contentLayer;
  self.sublayers = contentLayer ? @[contentLayer] : nil;

  // update shimmering animation
  [self _updateShimmering];
}

- (void)setShimmering:(BOOL)shimmering
{
  if (shimmering != _shimmering) {
    _shimmering = shimmering;
    [self _updateShimmering];
  }
}

- (void)setShimmeringSpeed:(CGFloat)speed
{
  if (speed != _shimmeringSpeed) {
    _shimmeringSpeed = speed;
    [self _updateShimmering];
  }
}

- (void)setShimmeringHighlightLength:(CGFloat)length
{
  if (length != _shimmeringHighlightLength) {
    _shimmeringHighlightLength = length;
    [self _updateShimmering];
  }
}

- (void)setShimmeringDirection:(FBShimmerDirection)direction
{
  if (direction != _shimmeringDirection) {
    _shimmeringDirection = direction;
    [self _updateShimmering];
  }
}

- (void)setShimmeringPauseDuration:(CFTimeInterval)duration
{
  if (duration != _shimmeringPauseDuration) {
    _shimmeringPauseDuration = duration;
    [self _updateShimmering];
  }
}

- (void)setShimmeringAnimationOpacity:(CGFloat)shimmeringAnimationOpacity
{
  if (shimmeringAnimationOpacity != _shimmeringAnimationOpacity) {
    _shimmeringAnimationOpacity = shimmeringAnimationOpacity;
    [self _updateMaskColors];
  }
}

- (void)setShimmeringOpacity:(CGFloat)shimmeringOpacity
{
  if (shimmeringOpacity != _shimmeringOpacity) {
    _shimmeringOpacity = shimmeringOpacity;
    [self _updateMaskColors];
  }
}

- (void)setShimmeringBeginTime:(CFTimeInterval)beginTime
{
  if (beginTime != _shimmeringBeginTime) {
    _shimmeringBeginTime = beginTime;
    [self _updateShimmering];
  }
}

- (void)layoutSublayers
{
  [super layoutSublayers];
  CGRect r = self.bounds;
  _contentLayer.anchorPoint = CGPointMake(0.5, 0.5);
  _contentLayer.bounds = r;
  _contentLayer.position = CGPointMake(CGRectGetMidX(r), CGRectGetMidY(r));
  
  if (nil != _maskLayer) {
    [self _updateMaskLayout];
  }
}

- (void)setBounds:(CGRect)bounds
{
  CGRect oldBounds = self.bounds;
  [super setBounds:bounds];
 
  if (!CGRectEqualToRect(oldBounds, bounds)) {
    [self _updateShimmering];
  }
}

#pragma mark - Internal

/*
æ¸…é™¤è’™ç‰ˆ
*/
- (void)_clearMask
{
  if (nil == _maskLayer) {
    return;
  }

  BOOL disableActions = [CATransaction disableActions];
  [CATransaction setDisableActions:YES];

  self.maskLayer = nil;
  _contentLayer.mask = nil;
  
  [CATransaction setDisableActions:disableActions];
}

- (void)_createMaskIfNeeded
{
  if (_shimmering &amp;&amp; !_maskLayer) {
    _maskLayer = [FBShimmeringMaskLayer layer];
    _maskLayer.delegate = self;
    _contentLayer.mask = _maskLayer;
    [self _updateMaskColors];
    [self _updateMaskLayout];
  }
}

/*
ä¸ºè’™ç‰ˆåˆ›å»ºé¢œè‰²æ•°ç»„ã€‚
æ³¨é‡Šä¹Ÿè¯´äº†ï¼Œè’™ç‰ˆå¯¹åº”çš„CALayeræ‰€è¡¨ç°å‡ºæ¥çš„å±æ€§åªèƒ½æ˜¯é€æ˜åº¦ï¼Œé¢œè‰²ä»€ä¹ˆçš„éƒ½ä¸å¥½ä½¿
*/
- (void)_updateMaskColors
{
  if (nil == _maskLayer) {
    return;
  }

  // We create a gradient to be used as a mask.
  // In a mask, the colors do not matter, it's the alpha that decides the degree of masking.
  UIColor *maskedColor = [UIColor colorWithWhite:1.0 alpha:_shimmeringOpacity];
  UIColor *unmaskedColor = [UIColor colorWithWhite:1.0 alpha:_shimmeringAnimationOpacity];

  // Create a gradient from masked to unmasked to masked.
  _maskLayer.colors = @[(__bridge id)maskedColor.CGColor, (__bridge id)unmaskedColor.CGColor, (__bridge id)maskedColor.CGColor];
}

/*
æ›´æ–°è’™ç‰ˆå¸ƒå±€ layout
*/
- (void)_updateMaskLayout
{
  // Everything outside the mask layer is hidden, so we need to create a mask long enough for the shimmered layer to be always covered by the mask.
  CGFloat length = 0.0f;
  if (_shimmeringDirection == FBShimmerDirectionDown ||
      _shimmeringDirection == FBShimmerDirectionUp) {
    length = CGRectGetHeight(_contentLayer.bounds);
  } else {
    length = CGRectGetWidth(_contentLayer.bounds);
  }
  if (0 == length) {
    return;
  }

  // extra distance for the gradient to travel during the pause.
  CGFloat extraDistance = length + _shimmeringSpeed * _shimmeringPauseDuration;

  // compute how far the shimmering goes
  CGFloat fullShimmerLength = length * 3.0f + extraDistance;
  CGFloat travelDistance = length * 2.0f + extraDistance;
  
  // position the gradient for the desired width
  CGFloat highlightOutsideLength = (1.0 - _shimmeringHighlightLength) / 2.0;
  _maskLayer.locations = @[@(highlightOutsideLength),
                           @(0.5),
                           @(1.0 - highlightOutsideLength)];

  CGFloat startPoint = (length + extraDistance) / fullShimmerLength;
  CGFloat endPoint = travelDistance / fullShimmerLength;
  
  // position for the start of the animation
  _maskLayer.anchorPoint = CGPointZero;
  if (_shimmeringDirection == FBShimmerDirectionDown ||
      _shimmeringDirection == FBShimmerDirectionUp) {
    _maskLayer.startPoint = CGPointMake(0.0, startPoint);
    _maskLayer.endPoint = CGPointMake(0.0, endPoint);
    _maskLayer.position = CGPointMake(0.0, -travelDistance);
    _maskLayer.bounds = CGRectMake(0.0, 0.0, CGRectGetWidth(_contentLayer.bounds), fullShimmerLength);
  } else {
    _maskLayer.startPoint = CGPointMake(startPoint, 0.0);
    _maskLayer.endPoint = CGPointMake(endPoint, 0.0);
    _maskLayer.position = CGPointMake(-travelDistance, 0.0);
    _maskLayer.bounds = CGRectMake(0.0, 0.0, fullShimmerLength, CGRectGetHeight(_contentLayer.bounds));
  }
}

/*
æƒ³æ¥è¿™ä¸ªæ–¹æ³•åº”è¯¥æ˜¯æœ€æ ¸å¿ƒçš„éƒ¨åˆ†ã€‚
*/
- (void)_updateShimmering
{
  // create mask if needed
  [self _createMaskIfNeeded];

  // if not shimmering and no mask, noop
  if (!_shimmering &amp;&amp; !_maskLayer) {
    return;
  }

  // ä¿è¯ layout
  // ensure layout
  [self layoutIfNeeded];
  
  // åˆ¤æ–­åŠ¨ç”»æ˜¯å¦å·²å¤±æ•ˆ
  BOOL disableActions = [CATransaction disableActions];
  if (!_shimmering) {
    if (disableActions) {
      // å‡å¦‚ä¸æ’­æ”¾åŠ¨ç”»ä¸”åŠ¨ç”»å·²å¤±æ•ˆï¼Œæ¸…é™¤maskLayer
      // simply remove mask
      [self _clearMask];
    } else {
      // ç»“æŸæ»‘è¡Œ
      // end slide
      CFTimeInterval slideEndTime = 0;

      // æ ¹æ®keyè·å–åŠ¨ç”»
      CAAnimation *slideAnimation = [_maskLayer animationForKey:kFBShimmerSlideAnimationKey];
      if (slideAnimation != nil) {

        // è·å–æ»‘åŠ¨çš„æ€»æ—¶é—´
        // determine total time sliding
        CFTimeInterval now = CACurrentMediaTime();
        CFTimeInterval slideTotalDuration = now - slideAnimation.beginTime;
		
        // æ ¹æ®å·²æ’­æ”¾æ—¶é—´å’Œæ€»ä½“æ—¶é—´æ±‚å‡ºå‰©ä½™æ—¶é—´
        // determine time offset into current slide
        CFTimeInterval slideTimeOffset = fmod(slideTotalDuration, slideAnimation.duration);

        // ç»“æŸåŠ¨ç”»
        // transition to non-repeating slide
        CAAnimation *finishAnimation = shimmer_slide_finish(slideAnimation);

        // ç»“æŸåŠ¨ç”»çš„å¼€å§‹æ—¶é—´
        // adjust begin time to now - offset
        finishAnimation.beginTime = now - slideTimeOffset;
		
        // è®¾å®šç»“æŸæ—¶é—´ï¼Œå¹¶æ·»åŠ ç»“æŸåŠ¨ç”»
        // note slide end time and begin
        slideEndTime = finishAnimation.beginTime + slideAnimation.duration;
        [_maskLayer addAnimation:finishAnimation forKey:kFBShimmerSlideAnimationKey];
      }
	  // åœ¨ç»“æŸåŠ¨ç”»æ’­æ”¾å®Œæ¯•åæ’­æ”¾æ·¡å…¥åŠ¨ç”»ï¼ˆè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ·¡å…¥æ·¡å‡ºåŠ¨ç”»éƒ½æ˜¯å¯¹maskLayerçš„å­layer fadeLayerèµ·ä½œç”¨ï¼‰
      // fade in text at slideEndTime
      CABasicAnimation *fadeInAnimation = fade_animation(_maskLayer.fadeLayer, 1.0, _shimmeringEndFadeDuration);
      fadeInAnimation.delegate = self;
      [fadeInAnimation setValue:@YES forKey:kFBEndFadeAnimationKey];
      fadeInAnimation.beginTime = slideEndTime;
      [_maskLayer.fadeLayer addAnimation:fadeInAnimation forKey:kFBFadeAnimationKey];

      // æ·¡å…¥æ·¡å‡ºåŠ¨ç”»çš„å¼€å§‹æ—¶é—´ä¸ºä½ç§»åŠ¨ç”»çš„ç»“æŸæ—¶é—´(è¿™ä¸€æ­¥åªåšæ•°æ®å±•ç¤ºï¼Œå¯¹æ•´ä½“åŠ¨ç”»æ²¡å½±å“)
      // expose end time for synchronization
      _shimmeringFadeTime = slideEndTime;
    }
  } else {
    // æ·¡å‡º
    // fade out text, optionally animated
    CABasicAnimation *fadeOutAnimation = nil;
    if (_shimmeringBeginFadeDuration &gt; 0.0 &amp;&amp; !disableActions) {
      fadeOutAnimation = fade_animation(_maskLayer.fadeLayer, 0.0, _shimmeringBeginFadeDuration);
      [_maskLayer.fadeLayer addAnimation:fadeOutAnimation forKey:kFBFadeAnimationKey];
    } else {
      BOOL innerDisableActions = [CATransaction disableActions];
      [CATransaction setDisableActions:YES];

      _maskLayer.fadeLayer.opacity = 0.0;
      [_maskLayer.fadeLayer removeAllAnimations];
      
      [CATransaction setDisableActions:innerDisableActions];
    }

    // å¼€å§‹æ»‘åŠ¨åŠ¨ç”»
    // begin slide animation
    CAAnimation *slideAnimation = [_maskLayer animationForKey:kFBShimmerSlideAnimationKey];
    
    // compute shimmer duration
    CGFloat length = 0.0f;
    if (_shimmeringDirection == FBShimmerDirectionDown ||
        _shimmeringDirection == FBShimmerDirectionUp) {
      length = CGRectGetHeight(_contentLayer.bounds);
    } else {
      length = CGRectGetWidth(_contentLayer.bounds);
    }
    CFTimeInterval animationDuration = (length / _shimmeringSpeed) + _shimmeringPauseDuration;
    
    if (slideAnimation != nil) {
      // ensure existing slide animation repeats
      [_maskLayer addAnimation:shimmer_slide_repeat(slideAnimation, animationDuration, _shimmeringDirection) forKey:kFBShimmerSlideAnimationKey];
    } else {
      // add slide animation
      slideAnimation = shimmer_slide_animation(animationDuration, _shimmeringDirection);
      slideAnimation.fillMode = kCAFillModeForwards;
      slideAnimation.removedOnCompletion = NO;
      if (_shimmeringBeginTime == FBShimmerDefaultBeginTime) {
        _shimmeringBeginTime = CACurrentMediaTime() + fadeOutAnimation.duration;
      }
      slideAnimation.beginTime = _shimmeringBeginTime;
      
      [_maskLayer addAnimation:slideAnimation forKey:kFBShimmerSlideAnimationKey];
    }
  }
}

#pragma mark - CALayerDelegate

- (id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event
{
  // no associated actions
  return (id)kCFNull;
}

#pragma mark - CAAnimationDelegate

- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
{
  if (flag &amp;&amp; [[anim valueForKey:kFBEndFadeAnimationKey] boolValue]) {
    [_maskLayer.fadeLayer removeAnimationForKey:kFBFadeAnimationKey];

    [self _clearMask];
  }
}

@end

</code></pre>

:ET