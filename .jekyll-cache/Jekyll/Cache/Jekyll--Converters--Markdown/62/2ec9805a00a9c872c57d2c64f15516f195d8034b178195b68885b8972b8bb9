I"¸
<pre><code class="language-objective-c">//
//  UIView.h
//  UIKit
//
//  Copyright (c) 2005-2017 Apple Inc. All rights reserved.
//

// åŸºç¡€æ¡†æ¶å…¥å£
#import &lt;Foundation/Foundation.h&gt;
#import &lt;QuartzCore/QuartzCore.h&gt;
#import &lt;UIKit/UIResponder.h&gt;
#import &lt;UIKit/UIInterface.h&gt;
#import &lt;UIKit/UIKitDefines.h&gt;
#import &lt;UIKit/UIAppearance.h&gt;
#import &lt;UIKit/UIDynamicBehavior.h&gt;
#import &lt;UIKit/NSLayoutConstraint.h&gt;
#import &lt;UIKit/UITraitCollection.h&gt;
#import &lt;UIKit/UIFocus.h&gt;

// ------------------------------------------------------------------------------------
// UIViewAnimationCurveè®¾ç½®åŠ¨ç”»å—ä¸­çš„åŠ¨ç”»å±æ€§å˜åŒ–çš„æ›²çº¿
typedef NS_ENUM(NSInteger, UIViewAnimationCurve) {
    // slow at beginning and end  ç¼“å…¥ç¼“å‡ºï¼Œä¸­é—´å¿«
    UIViewAnimationCurveEaseInOut,
    // slow at beginning ç”±æ…¢åˆ°ç‰¹åˆ«å¿«ï¼ˆç¼“å…¥å¿«å‡ºï¼‰
    UIViewAnimationCurveEaseIn,
    // slow at end ç”±å¿«åˆ°æ…¢(å¿«å…¥ç¼“å‡º)
    UIViewAnimationCurveEaseOut,
    // åŠ¨ç”»åŒ€é€Ÿæ‰§è¡Œï¼Œé»˜è®¤å€¼ã€‚
    UIViewAnimationCurveLinear
};

// ------------------------------------------------------------------------------------
typedef NS_ENUM(NSInteger, UIViewContentMode) {
    // ä¼¸ç¼©è‡³é«˜åº¦åŠå®½åº¦ä¸UIViewçš„å¤§å°ä¸€è‡´ï¼Œé»˜è®¤å€¼
    UIViewContentModeScaleToFill,
    // contents scaled to fit with fixed aspect. remainder is transparent
    // åœ¨ä¸è¶…å‡ºUIViewå°ºå¯¸èŒƒå›´å†…ï¼Œä¸”ä¸æ”¹å˜æ¯”ä¾‹çš„æƒ…å†µä¸‹ä¼¸ç¼©è‡³æœ€å¤§å°ºå¯¸ï¼Œè¾¹ç•Œå¤šä½™éƒ¨åˆ†é€æ˜
    UIViewContentModeScaleAspectFit,
    // contents scaled to fill with fixed aspect. some portion of content may be clipped.
    // è¶…å‡ºUIViewçš„é«˜åº¦æˆ–è€…å®½åº¦ï¼Œä¼¸ç¼©è‡³ä¸æ”¹å˜æ¯”ä¾‹çš„æœ€å¤§å°ºå¯¸ï¼Œè¾¹ç•Œå¤šä½™çš„éƒ¨åˆ†å¯èƒ½ä¼šè¢«å‰ªåˆ‡æ‰
    UIViewContentModeScaleAspectFill,
    // redraw on bounds change (calls -setNeedsDisplay) é‡ç»˜è§†å›¾è¾¹ç•Œ
    UIViewContentModeRedraw,
    // contents remain same size. positioned adjusted. è§†å›¾ä¿æŒç­‰æ¯”ç¼©æ”¾
    UIViewContentModeCenter,
    UIViewContentModeTop, // è§†å›¾é¡¶éƒ¨å¯¹é½
    UIViewContentModeBottom,// è§†å›¾åº•éƒ¨å¯¹é½
    UIViewContentModeLeft, // è§†å›¾å·¦ä¾§å¯¹é½
    UIViewContentModeRight, // è§†å›¾å³ä¾§å¯¹é½
    UIViewContentModeTopLeft, // è§†å›¾å·¦ä¸Šè§’å¯¹é½
    UIViewContentModeTopRight, // è§†å›¾å³ä¸Šè§’å¯¹é½
    UIViewContentModeBottomLeft, // è§†å›¾å·¦ä¸‹è§’å¯¹é½
    UIViewContentModeBottomRight, // è§†å›¾å³ä¸‹è§’å¯¹é½
};

// ------------------------------------------------------------------------------------
// è¿‡æ¸¡åŠ¨ç”»æ•ˆæœ
typedef NS_ENUM(NSInteger, UIViewAnimationTransition) {
    UIViewAnimationTransitionNone,          // ä¸ä½¿ç”¨åŠ¨ç”»
    UIViewAnimationTransitionFlipFromLeft,  // ä»å·¦å‘å³æ—‹è½¬ç¿»é¡µ
    UIViewAnimationTransitionFlipFromRight, // ä»å³å‘å·¦æ—‹è½¬ç¿»é¡µ
    UIViewAnimationTransitionCurlUp,        // å·æ›²ç¿»é¡µ,ä»ä¸‹å¾€ä¸Š
    UIViewAnimationTransitionCurlDown,      // å·æ›²ç¿»é¡µï¼Œä»ä¸Šå¾€ä¸‹
};

// ------------------------------------------------------------------------------------
typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {
    // ä¸è‡ªåŠ¨è°ƒæ•´, é»˜è®¤å€¼
    UIViewAutoresizingNone                 = 0,
    // è‡ªåŠ¨è°ƒæ•´ä¸superViewå·¦è¾¹çš„è·ç¦»ï¼Œä¿è¯ä¸superViewå³è¾¹çš„è·ç¦»ä¸å˜
    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,
    // è‡ªåŠ¨è°ƒæ•´è‡ªå·±çš„å®½åº¦ï¼Œä¿è¯ä¸superViewå·¦è¾¹å’Œå³è¾¹çš„è·ç¦»ä¸å˜
    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,
    // è‡ªåŠ¨è°ƒæ•´ä¸superViewå³è¾¹çš„è·ç¦»ï¼Œä¿è¯ä¸superViewå·¦è¾¹çš„è·ç¦»ä¸å˜
    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,
    // è‡ªåŠ¨è°ƒæ•´ä¸superViewé¡¶éƒ¨çš„è·ç¦»ï¼Œä¿è¯ä¸superViewåº•éƒ¨çš„è·ç¦»ä¸å˜
    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,
    // è‡ªåŠ¨è°ƒæ•´è‡ªå·±çš„å®½åº¦ï¼Œä¿è¯ä¸superViewä¸Šè¾¹å’Œä¸‹è¾¹çš„è·ç¦»ä¸å˜
    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,
    // è‡ªåŠ¨è°ƒæ•´ä¸superViewåº•éƒ¨çš„è·ç¦»ï¼Œä¿è¯ä¸superViewé¡¶éƒ¨çš„è·ç¦»ä¸å˜
    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5
};

// ------------------------------------------------------------------------------------
typedef NS_OPTIONS(NSUInteger, UIViewAnimationOptions) {
    // åŠ¨ç”»è¿‡ç¨‹ä¸­ä¿è¯å­è§†å›¾è·Ÿéšè¿åŠ¨ã€‚æäº¤åŠ¨ç”»çš„æ—¶å€™å¸ƒå±€å­æ§ä»¶ï¼Œè¡¨ç¤ºå­æ§ä»¶å°†å’Œçˆ¶æ§ä»¶ä¸€åŒåŠ¨ç”»ã€‚
    UIViewAnimationOptionLayoutSubviews            = 1 &lt;&lt;  0,
    // åŠ¨ç”»è¿‡ç¨‹ä¸­å…è®¸ç”¨æˆ·äº¤äº’ã€‚
    UIViewAnimationOptionAllowUserInteraction      = 1 &lt;&lt;  1, // turn on user interaction while animating
    // æ‰€æœ‰è§†å›¾ä»å½“å‰çŠ¶æ€å¼€å§‹è¿è¡Œã€‚
    UIViewAnimationOptionBeginFromCurrentState     = 1 &lt;&lt;  2, // start all views from current value, not initial value
    // é‡å¤è¿è¡ŒåŠ¨ç”»ã€‚
    UIViewAnimationOptionRepeat                    = 1 &lt;&lt;  3, // repeat animation indefinitely
    // åŠ¨ç”»è¿è¡Œåˆ°ç»“æŸç‚¹åä»ç„¶ä»¥åŠ¨ç”»æ–¹å¼å›åˆ°åˆå§‹ç‚¹ã€‚æ‰§è¡ŒåŠ¨ç”»å›è·¯,å‰ææ˜¯è®¾ç½®åŠ¨ç”»æ— é™é‡å¤
    UIViewAnimationOptionAutoreverse               = 1 &lt;&lt;  4, // if repeat, run animation back and forth
    // å¿½ç•¥åµŒå¥—åŠ¨ç”»æ—¶é—´è®¾ç½®ï¼Œ å¿½ç•¥å¤–å±‚åŠ¨ç”»åµŒå¥—çš„æ—¶é—´å˜åŒ–æ›²çº¿
    UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt;  5, // ignore nested duration
    // å¿½ç•¥åµŒå¥—åŠ¨ç”»é€Ÿåº¦è®¾ç½® é€šè¿‡æ”¹å˜å±æ€§å’Œé‡ç»˜å®ç°åŠ¨ç”»æ•ˆæœï¼Œå¦‚æœkeyæ²¡æœ‰æäº¤åŠ¨ç”»å°†ä½¿ç”¨å¿«ç…§
    UIViewAnimationOptionOverrideInheritedCurve    = 1 &lt;&lt;  6, // ignore nested curve
    // åŠ¨ç”»è¿‡ç¨‹ä¸­é‡ç»˜è§†å›¾ï¼ˆæ³¨æ„ä»…ä»…é€‚ç”¨äºè½¬åœºåŠ¨ç”»ï¼‰ã€‚
    UIViewAnimationOptionAllowAnimatedContent      = 1 &lt;&lt;  7, // animate contents (applies to transitions only)
    // è§†å›¾åˆ‡æ¢æ—¶ç›´æ¥éšè—æ—§è§†å›¾ã€æ˜¾ç¤ºæ–°è§†å›¾ï¼Œè€Œä¸æ˜¯å°†æ—§è§†å›¾ä»çˆ¶è§†å›¾ç§»é™¤ï¼ˆä»…ä»…é€‚ç”¨äºè½¬åœºåŠ¨ç”»ï¼‰**ç”¨æ˜¾éšçš„æ–¹å¼æ›¿ä»£æ·»åŠ ç§»é™¤å›¾å±‚çš„åŠ¨ç”»æ•ˆæœ**
    UIViewAnimationOptionShowHideTransitionViews   = 1 &lt;&lt;  8, // flip to/from hidden state instead of adding/removing
    // ä¸ç»§æ‰¿çˆ¶åŠ¨ç”»è®¾ç½®æˆ–åŠ¨ç”»ç±»å‹ã€‚
    UIViewAnimationOptionOverrideInheritedOptions  = 1 &lt;&lt;  9, // do not inherit any options or animation type
    
    // åŠ¨ç”»é€Ÿåº¦æ§åˆ¶ï¼ˆå¯ä»å…¶ä¸­é€‰æ‹©ä¸€ä¸ªè®¾ç½®ï¼‰æ—¶é—´å‡½æ•°æ›²çº¿ç›¸å…³
    // åŠ¨ç”»å…ˆç¼“æ…¢ï¼Œç„¶åé€æ¸åŠ é€Ÿ
    UIViewAnimationOptionCurveEaseInOut            = 0 &lt;&lt; 16, // default
    // åŠ¨ç”»é€æ¸å˜æ…¢ã€‚
    UIViewAnimationOptionCurveEaseIn               = 1 &lt;&lt; 16,
    // åŠ¨ç”»é€æ¸åŠ é€Ÿã€‚
    UIViewAnimationOptionCurveEaseOut              = 2 &lt;&lt; 16,
    // åŠ¨ç”»åŒ€é€Ÿæ‰§è¡Œ
    UIViewAnimationOptionCurveLinear               = 3 &lt;&lt; 16,
    
    // è½¬åœºç±»å‹ï¼ˆä»…é€‚ç”¨äºè½¬åœºåŠ¨ç”»è®¾ç½®ï¼Œå¯ä»¥ä»ä¸­é€‰æ‹©ä¸€ä¸ªè¿›è¡Œè®¾ç½®ï¼ŒåŸºæœ¬åŠ¨ç”»ã€å…³é”®å¸§åŠ¨ç”»ä¸éœ€è¦è®¾ç½®ï¼‰
    // æ²¡æœ‰è½¬åœºåŠ¨ç”»æ•ˆæœã€‚
    UIViewAnimationOptionTransitionNone            = 0 &lt;&lt; 20, // default
    // ä»å·¦ä¾§ç¿»è½¬æ•ˆæœã€‚
    UIViewAnimationOptionTransitionFlipFromLeft    = 1 &lt;&lt; 20,
    // ä»å‹ä¾§ç¿»è½¬æ•ˆæœã€‚
    UIViewAnimationOptionTransitionFlipFromRight   = 2 &lt;&lt; 20,
    // å‘åç¿»é¡µçš„åŠ¨ç”»è¿‡æ¸¡æ•ˆæœã€‚
    UIViewAnimationOptionTransitionCurlUp          = 3 &lt;&lt; 20,
    // å‘å‰ç¿»é¡µçš„åŠ¨ç”»è¿‡æ¸¡æ•ˆæœã€‚
    UIViewAnimationOptionTransitionCurlDown        = 4 &lt;&lt; 20,
    // æ—§è§†å›¾æº¶è§£æ¶ˆå¤±æ˜¾ç¤ºä¸‹ä¸€ä¸ªæ–°è§†å›¾çš„æ•ˆæœã€‚
    UIViewAnimationOptionTransitionCrossDissolve   = 5 &lt;&lt; 20,
    // ä»ä¸Šæ–¹ç¿»è½¬æ•ˆæœã€‚
    UIViewAnimationOptionTransitionFlipFromTop     = 6 &lt;&lt; 20,
    // ä»åº•éƒ¨ç¿»è½¬æ•ˆæœã€‚
    UIViewAnimationOptionTransitionFlipFromBottom  = 7 &lt;&lt; 20,
    
    // é»˜è®¤çš„å¸§æ¯ç§’.
    UIViewAnimationOptionPreferredFramesPerSecondDefault     = 0 &lt;&lt; 24,
    // 60å¸§æ¯ç§’çš„å¸§é€Ÿç‡.
    UIViewAnimationOptionPreferredFramesPerSecond60          = 3 &lt;&lt; 24,
    // 30å¸§æ¯ç§’çš„å¸§é€Ÿç‡.
    UIViewAnimationOptionPreferredFramesPerSecond30          = 7 &lt;&lt; 24,
} NS_ENUM_AVAILABLE_IOS(4_0);

// ------------------------------------------------------------------------------------
typedef NS_OPTIONS(NSUInteger, UIViewKeyframeAnimationOptions) {
    UIViewKeyframeAnimationOptionLayoutSubviews            = UIViewAnimationOptionLayoutSubviews,
    UIViewKeyframeAnimationOptionAllowUserInteraction      = UIViewAnimationOptionAllowUserInteraction, // turn on user interaction while animating
    UIViewKeyframeAnimationOptionBeginFromCurrentState     = UIViewAnimationOptionBeginFromCurrentState, // start all views from current value, not initial value
    UIViewKeyframeAnimationOptionRepeat                    = UIViewAnimationOptionRepeat, // repeat animation indefinitely
    UIViewKeyframeAnimationOptionAutoreverse               = UIViewAnimationOptionAutoreverse, // if repeat, run animation back and forth
    UIViewKeyframeAnimationOptionOverrideInheritedDuration = UIViewAnimationOptionOverrideInheritedDuration, // ignore nested duration
    UIViewKeyframeAnimationOptionOverrideInheritedOptions  = UIViewAnimationOptionOverrideInheritedOptions, // do not inherit any options or animation type
    
    // è¿ç»­è¿ç®—æ¨¡å¼, é»˜è®¤
    UIViewKeyframeAnimationOptionCalculationModeLinear     = 0 &lt;&lt; 10, // default
    // ç¦»æ•£è¿ç®—æ¨¡å¼.
    UIViewKeyframeAnimationOptionCalculationModeDiscrete   = 1 &lt;&lt; 10,
    // å‡åŒ€æ‰§è¡Œè¿ç®—æ¨¡å¼.
    UIViewKeyframeAnimationOptionCalculationModePaced      = 2 &lt;&lt; 10,
    // å¹³æ»‘è¿ç®—æ¨¡å¼.
    UIViewKeyframeAnimationOptionCalculationModeCubic      = 3 &lt;&lt; 10,
    // å¹³æ»‘å‡åŒ€è¿ç®—æ¨¡å¼.
    UIViewKeyframeAnimationOptionCalculationModeCubicPaced = 4 &lt;&lt; 10
} NS_ENUM_AVAILABLE_IOS(7_0);

// ------------------------------------------------------------------------------------
// ç³»ç»ŸåŠ¨ç”»ç›¸å…³æšä¸¾
typedef NS_ENUM(NSUInteger, UISystemAnimation) {
    // ç³»ç»Ÿè‡ªå¸¦åˆ é™¤åŠ¨ç”»
    UISystemAnimationDelete,    // removes the views from the hierarchy when complete ç³»ç»Ÿè‡ªå¸¦åˆ é™¤åŠ¨ç”»
} NS_ENUM_AVAILABLE_IOS(7_0);

// ------------------------------------------------------------------------------------
typedef NS_ENUM(NSInteger, UIViewTintAdjustmentMode) {
    UIViewTintAdjustmentModeAutomatic, // è‡ªåŠ¨çš„ï¼Œä¸çˆ¶è§†å›¾ç›¸åŒ.
    
    UIViewTintAdjustmentModeNormal, // æ­£å¸¸æ²¡æœ‰ä¿®æ”¹
    UIViewTintAdjustmentModeDimmed, //tintColorçš„é»˜è®¤å€¼ä¼šè‡ªåŠ¨å˜å¾—æ¨¡ç³Š
} NS_ENUM_AVAILABLE_IOS(7_0);

// ------------------------------------------------------------------------------------
typedef NS_ENUM(NSInteger, UISemanticContentAttribute) {
    // æœªæŒ‡å®šï¼Œé»˜è®¤å€¼
    UISemanticContentAttributeUnspecified = 0,
    //  æ‰“å¼€/ RW / FFç­‰æ’­æ”¾æ§åˆ¶æŒ‰é’®
    UISemanticContentAttributePlayback, // for playback controls such as Play/RW/FF buttons and playhead scrubbers
    // æ§åˆ¶å¯¼è‡´æŸç§å½¢å¼çš„å®šå‘æ”¹å˜UIä¸­,å¦‚åˆ†æ®µæ§åˆ¶æ–‡æœ¬å¯¹é½æ–¹å¼æˆ–åœ¨æ¸¸æˆä¸­æ–¹å‘é”®
    UISemanticContentAttributeSpatial, // for controls that result in some sort of directional change in the UI, e.g. a segmented control for text alignment or a D-pad in a game
    // è§†å›¾æ€»æ˜¯ä»å·¦å‘å³å¸ƒå±€.
    UISemanticContentAttributeForceLeftToRight,
    // è§†å›¾æ€»æ˜¯ä»åˆå‘å·¦å¸ƒå±€.
    UISemanticContentAttributeForceRightToLeft
} NS_ENUM_AVAILABLE_IOS(9_0);

// ------------------------------------------------------------------------------------
// åæ ‡ç³»ç©ºé—´ç›¸å…³çš„åè®®
@protocol UICoordinateSpace &lt;NSObject&gt;

/** å°†åƒç´ pointç”±pointæ‰€åœ¨è§†å›¾è½¬æ¢åˆ°ç›®æ ‡è§†å›¾viewä¸­ï¼Œè¿”å›åœ¨ç›®æ ‡è§†å›¾viewä¸­çš„åƒç´ å€¼ */
- (CGPoint)convertPoint:(CGPoint)point toCoordinateSpace:(id &lt;UICoordinateSpace&gt;)coordinateSpace NS_AVAILABLE_IOS(8_0);
/** å°†åƒç´ pointç”±pointæ‰€åœ¨è§†å›¾è½¬æ¢åˆ°ç›®æ ‡è§†å›¾viewä¸­ï¼Œè¿”å›åœ¨ç›®æ ‡è§†å›¾viewä¸­çš„åƒç´ å€¼ */
- (CGPoint)convertPoint:(CGPoint)point fromCoordinateSpace:(id &lt;UICoordinateSpace&gt;)coordinateSpace NS_AVAILABLE_IOS(8_0);
/** å°†rectç”±rectæ‰€åœ¨è§†å›¾è½¬æ¢åˆ°ç›®æ ‡è§†å›¾viewä¸­ï¼Œè¿”å›åœ¨ç›®æ ‡è§†å›¾viewä¸­çš„rect */
- (CGRect)convertRect:(CGRect)rect toCoordinateSpace:(id &lt;UICoordinateSpace&gt;)coordinateSpace NS_AVAILABLE_IOS(8_0);
/** å°†rectä»viewä¸­è½¬æ¢åˆ°å½“å‰è§†å›¾ä¸­ï¼Œè¿”å›åœ¨å½“å‰è§†å›¾ä¸­çš„rect */
- (CGRect)convertRect:(CGRect)rect fromCoordinateSpace:(id &lt;UICoordinateSpace&gt;)coordinateSpace NS_AVAILABLE_IOS(8_0);

/** è·å–bounds åªè¯» */
@property (readonly, nonatomic) CGRect bounds NS_AVAILABLE_IOS(8_0);

@end

@class UIBezierPath, UIEvent, UIWindow, UIViewController, UIColor, UIGestureRecognizer, UIMotionEffect, CALayer, UILayoutGuide;

// UIViewæ˜¯iOSç³»ç»Ÿä¸­ç•Œé¢å…ƒç´ çš„åŸºç¡€ï¼Œæ‰€æœ‰çš„ç•Œé¢å…ƒç´ éƒ½ç»§æ‰¿è‡ªå®ƒã€‚UIViewæœ¬èº«å®Œå…¨æ˜¯ç”±CoreAnimationæ¥å®ç°çš„ã€‚å®ƒçœŸæ­£çš„ç»˜å›¾éƒ¨åˆ†æ˜¯ç”±ä¸€ä¸ªå«CALayerï¼ˆCore Animation Layerï¼‰çš„ç±»æ¥ç®¡ç†ã€‚UIViewæœ¬èº«ï¼Œæ›´åƒæ˜¯ä¸€ä¸ªCALayerçš„ç®¡ç†å™¨ï¼Œè®¿é—®å®ƒçš„è·Ÿç»˜å›¾å’Œåæ ‡æœ‰å…³çš„å±æ€§ï¼Œå¦‚frameï¼Œboundsç­‰ï¼Œè€Œå†…éƒ¨éƒ½æ˜¯åœ¨è®¿é—®å®ƒæ‰€åŒ…å«çš„CALayerçš„ç›¸å…³å±æ€§ã€‚
// UIViewç»§æ‰¿è‡ªUIResponder UIResponderæ˜¯æ‰€æœ‰äº‹ä»¶çš„å“åº”åŸºçŸ³ã€‚

NS_CLASS_AVAILABLE_IOS(2_0) @interface UIView : UIResponder &lt;NSCoding, UIAppearance, UIAppearanceContainer, UIDynamicItem, UITraitEnvironment, UICoordinateSpace, UIFocusItem, CALayerDelegate&gt;

#if UIKIT_DEFINE_AS_PROPERTIES
@property(class, nonatomic, readonly) Class layerClass;                        // default is [CALayer class]. Used when creating the underlying layer for the view.
#else
// UIViewæœ‰ä¸ªlayerå±æ€§ï¼Œå¯ä»¥è¿”å›å®ƒçš„ä¸»CALayerå®ä¾‹ï¼ŒUIViewæœ‰ä¸€ä¸ªlayerClassæ–¹æ³•ï¼Œè¿”å›ä¸»layeræ‰€ä½¿ç”¨çš„ç±»ï¼ŒUIViewçš„å­ç±»å¯ä»¥é€šè¿‡é‡è½½è¿™ä¸ªæ–¹æ³•æ¥è®©UIViewä½¿ç”¨ä¸åŒçš„CALayeræ¥æ˜¾ç¤º
+ (Class)layerClass;   // default is [CALayer class]. Used when creating the underlying layer for the view.
#endif


// å½“ä»ä»£ç å®ä¾‹åŒ–UIViewçš„æ—¶å€™ï¼ŒinitWithFrameä¼šæ‰§è¡Œï¼›
// å½“ä»æ–‡ä»¶åŠ è½½UIViewçš„æ—¶å€™ï¼ŒinitWithCoderä¼šæ‰§è¡Œã€‚
// åˆå§‹åŒ–æ–¹æ³•å¹¶ä¸”ç»™ä¸€ä¸ªframe
- (instancetype)initWithFrame:(CGRect)frame;          // default initializer

- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;

// æ˜¯å¦æ¥å—ç”¨æˆ·ç‚¹å‡» getter=isUserInterractionEnabled é‡æ„getteræ–¹æ³•
@property(nonatomic,getter=isUserInteractionEnabled) BOOL userInteractionEnabled;  // default is YES. if set to NO, user events (touch, keys) are ignored and removed from the event queue.
// ç»™UIViewåŠ ä¸€ä¸ªtagé»˜è®¤æ˜¯0
@property(nonatomic)                                 NSInteger tag;                // default is 0
// è¿”å›viewçš„layer
@property(nonatomic,readonly,retain)                 CALayer  *layer;              // returns view's layer. Will always return a non-nil value. view is layer's delegate


/** è¿”å›æ˜¯å¦å¯ä»¥æˆä¸ºç„¦ç‚¹, é»˜è®¤NO */
#if UIKIT_DEFINE_AS_PROPERTIES
@property(nonatomic,readonly) BOOL canBecomeFocused NS_AVAILABLE_IOS(9_0); // NO by default //æ˜¯å¦èƒ½è¢«è®¾ç½®ä¸ºé«˜äº®
#else
- (BOOL)canBecomeFocused NS_AVAILABLE_IOS(9_0); // NO by default
#endif

/** æ˜¯å¦å¯ä»¥è¢«èšç„¦ */
@property (readonly, nonatomic, getter=isFocused) BOOL focused NS_AVAILABLE_IOS(9_0);

/** å·¦å³æ»‘åŠ¨ç¿»è½¬æ•ˆæœ */
@property (nonatomic) UISemanticContentAttribute semanticContentAttribute NS_AVAILABLE_IOS(9_0);

/** è·å–è§†å›¾çš„æ–¹å‘ */
// This method returns the layout direction implied by the provided semantic content attribute relative to the application-wide layout direction (as returned by UIApplication.sharedApplication.userInterfaceLayoutDirection).
+ (UIUserInterfaceLayoutDirection)userInterfaceLayoutDirectionForSemanticContentAttribute:(UISemanticContentAttribute)attribute NS_AVAILABLE_IOS(9_0);

/** è·å–ç›¸å¯¹äºæŒ‡å®šè§†å›¾çš„ç•Œé¢æ–¹å‘ */
// This method returns the layout direction implied by the provided semantic content attribute relative to the provided layout direction. For example, when provided a layout direction of RightToLeft and a semantic content attribute of Playback, this method returns LeftToRight. Layout and drawing code can use this method to determine how to arrange elements, but might find it easier to query the container viewâ€™s effectiveUserInterfaceLayoutDirection property instead.
+ (UIUserInterfaceLayoutDirection)userInterfaceLayoutDirectionForSemanticContentAttribute:(UISemanticContentAttribute)semanticContentAttribute relativeToLayoutDirection:(UIUserInterfaceLayoutDirection)layoutDirection NS_AVAILABLE_IOS(10_0);

/** è¿”å›å³æ—¶å†…å®¹çš„å¸ƒå±€çš„æ–¹å‘ */
// Returns the user interface layout direction appropriate for arranging the immediate content of this view. Always consult the effectiveUserInterfaceLayoutDirection of the view whose immediate content is being arranged or drawn. Do not assume that the value propagates through the viewâ€™s subtree.
@property (readonly, nonatomic) UIUserInterfaceLayoutDirection effectiveUserInterfaceLayoutDirection NS_AVAILABLE_IOS(10_0);


@end

@interface UIView(UIViewGeometry)

// animatable. do not use frame if view is transformed since it will not correctly reflect the actual location of the view. use bounds + center instead.
// frameæ˜¯æŒ‡è§†å›¾åœ¨å…¶çˆ¶è§†å›¾åæ ‡ç³»ä¸­çš„ä½ç½®ä¸å°ºå¯¸ã€‚å¯ä»¥ç”¨boundså’Œcenterä»£æ›¿
@property(nonatomic) CGRect            frame;

// use bounds/center and not frame if non-identity transform. if bounds dimension is odd, center may be have fractional part
// æ˜¯æŒ‡è§†å›¾åœ¨å…¶è‡ªå·±çš„åæ ‡ç³»(æœ‰ä¸€ä¸ªè‡ªèº«çš„åæ ‡ç³»)ä¸­çš„ä½ç½®å’Œå°ºå¯¸(ä¸çˆ¶è§†å›¾æ— å…³)
@property(nonatomic) CGRect            bounds;      // default bounds is zero origin, frame size. animatable
// è¯¥è§†å›¾çš„ä¸­å¿ƒç‚¹åœ¨å…¶çˆ¶è§†å›¾åæ ‡ç³»ä¸­çš„ä½ç½®åæ ‡
@property(nonatomic) CGPoint          center;      // center is center of frame. animatable
// å½¢å˜å±æ€§(å¹³ç§»\ç¼©æ”¾\æ—‹è½¬)
@property(nonatomic) CGAffineTransform transform;   // default is CGAffineTransformIdentity. animatable
@property(nonatomic) CGFloat          contentScaleFactor NS_AVAILABLE_IOS(4_0);
// getter=isMultipleTouchEnabled é‡æ„getteræ–¹æ³• å½“å‰Viewæ˜¯å¦æ”¯æŒå¤šç‚¹è§¦æ§äº‹ä»¶ é»˜è®¤NO
@property(nonatomic,getter=isMultipleTouchEnabled) BOOL multipleTouchEnabled;   // default is NO
// å†³å®šå½“å‰çš„viewæ˜¯å¦æ˜¯å¤„ç†è§¦æ‘¸äº‹ä»¶çš„å”¯ä¸€å¯¹è±¡(ä¸èƒ½åŒæ—¶ç‚¹å‡»å¤šä¸ªview) é»˜è®¤æ˜¯NO
@property(nonatomic,getter=isExclusiveTouch) BOOL      exclusiveTouch;         // default is NO

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;   // recursively calls -pointInside:withEvent:. point is in the receiver's coordinate system
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;   // default returns YES if point is in bounds

/**==========*******convertPonit****===================*/

/** å°†åƒç´ pointç”±pointæ‰€åœ¨è§†å›¾è½¬æ¢åˆ°ç›®æ ‡è§†å›¾viewä¸­ï¼Œè¿”å›åœ¨ç›®æ ‡è§†å›¾viewä¸­çš„åƒç´ å€¼ */
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView *)view;
/** å°†åƒç´ pointç”±pointæ‰€åœ¨è§†å›¾è½¬æ¢åˆ°ç›®æ ‡è§†å›¾viewä¸­ï¼Œè¿”å›åœ¨ç›®æ ‡è§†å›¾viewä¸­çš„åƒç´ å€¼ */
// CGPoint pointInView =  [self.redView convertPoint:pointInOriView fromView:self.view];
- (CGPoint)convertPoint:(CGPoint)point fromView:(UIView *)view;
/** å°†rectç”±rectæ‰€åœ¨è§†å›¾è½¬æ¢åˆ°ç›®æ ‡è§†å›¾viewä¸­ï¼Œè¿”å›åœ¨ç›®æ ‡è§†å›¾viewä¸­çš„rect */
- (CGRect)convertRect:(CGRect)rect toView:(UIView *)view;
/** å°†rectä»viewä¸­è½¬æ¢åˆ°å½“å‰è§†å›¾ä¸­ï¼Œè¿”å›åœ¨å½“å‰è§†å›¾ä¸­çš„rect */
- (CGRect)convertRect:(CGRect)rect fromView:(UIView *)view;

// ä¾‹æŠŠUITableViewCellä¸­çš„subview(btn)çš„frameè½¬æ¢åˆ° controllerAä¸­
// controllerA ä¸­æœ‰ä¸€ä¸ªUITableView, UITableViewé‡Œæœ‰å¤šè¡ŒUITableVieCellï¼Œcellä¸Šæ”¾æœ‰ä¸€ä¸ªbutton

/*
// åœ¨controllerAä¸­å®ç°:

CGRect rc = [cell convertRect:cell.btn.frame toView:self.view];

æˆ–

CGRect rc = [self.view convertRect:cell.btn.frame fromView:cell];

// æ­¤rcä¸ºbtnåœ¨controllerAä¸­çš„rect
æˆ–å½“å·²çŸ¥btnæ—¶ï¼š

CGRect rc = [btn.superview convertRect:btn.frame toView:self.view];

æˆ–

CGRect rc = [self.view convertRect:btn.frame fromView:btn.superview];
=================***************==========================*/

//å½“ä½ æ”¹å˜è§†å›¾çš„è¾¹æ¡†çŸ©å½¢æ—¶ï¼Œå…¶å†…åµŒçš„å­è§†å›¾çš„ä½ç½®å’Œå°ºå¯¸å¾€å¾€éœ€è¦æ”¹å˜ï¼Œä»¥é€‚åº”åŸå§‹è§†å›¾çš„æ–°å°ºå¯¸ã€‚å¦‚æœè§†å›¾çš„autoresizesSubViewså±æ€§å£°æ˜è¢«è®¾ç½®ä¸ºYESï¼Œå…¶å­è§†å›¾ä¼šæ ¹æ®autoresizingMaskå±æ€§çš„å€¼è‡ªåŠ¨è¿›è¡Œå°ºå¯¸è°ƒæ•´
@property(nonatomic) BOOL              autoresizesSubviews; // default is YES. if set, subviews are adjusted according to their autoresizingMask if self.bounds changes
// è®¾ç½®è§†å›¾çš„è‡ªåŠ¨å°ºå¯¸è°ƒæ•´è¡Œä¸ºçš„æ–¹æ³•æ˜¯é€šè¿‡ORæ“ä½œç¬¦è®²æœŸæœ›çš„è‡ªå®šå°ºå¯¸è°ƒæ•´å¸¸é‡è¿æ¥èµ·æ¥ã€‚å¹¶å°†ç»“æœèµ‹å€¼ç»™è§†å›¾çš„autoresizingMaskå±æ€§ã€‚æ¯”å¦‚è¦ä½¿ä¸€ä¸ªè§†å›¾å’Œå…¶çˆ¶è§†å›¾å·¦ä¸‹è§’çš„ç›¸å¯¹ä½ç½®ä¿æŒä¸å˜å¯ä»¥åŠ å…¥UIViewAutoresizingFlexibleRightMargin
@property(nonatomic) UIViewAutoresizing autoresizingMask;    // simple resize. default is UIViewAutoresizingNone
// è®¡ç®—å¹¶ä¸”è¿”å›ä¸€ä¸ªæœ€é€‚åº”æ¥æ”¶å­è§†å›¾çš„å¤§å°
- (CGSize)sizeThatFits:(CGSize)size;     // return 'best' size to fit given size. does not actually resize view. Default is return existing view size
//ç§»åŠ¨å¹¶è°ƒæ•´å­è§†å›¾çš„å¤§å°
- (void)sizeToFit;                       // calls sizeThatFits: with current view bounds and changes bounds size.

@end

@interface UIView(UIViewHierarchy)
//çˆ¶View
@property(nonatomic,readonly) UIView      *superview;
//å­view å­æ§ä»¶çš„å­æ§ä»¶å¹¶ä¸åœ¨é‡Œé¢
@property(nonatomic,readonly,copy) NSArray *subviews;
//çª—å£
@property(nonatomic,readonly) UIWindow    *window;
//å°†å½“å‰è§†å›¾ä»çˆ¶è§†å›¾å’Œçª—å£ç§»é™¤ï¼Œå¹¶ä¸”æŠŠä»–çš„å“åº”äº‹ä»¶çš„å“åº”é“¾ç§»é™¤
- (void)removeFromSuperview;
//æŒ‡å®šç´¢å¼•æ’å…¥è§†å›¾
- (void)insertSubview:(UIView *)view atIndex:(NSInteger)index;
//äº¤æ¢æŒ‡å®šç´¢å¼•çš„ä¸¤ä¸ªViewçš„ä½ç½®
- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;
//è§†å›¾çš„æ·»åŠ éƒ½æ˜¯ä»¥æ ˆçš„æ–¹å¼ï¼Œå…ˆè¿›å…ˆå‡º
//æ·»åŠ ä¸€ä¸ªå­æ§ä»¶(æ–°æ·»åŠ çš„æ§ä»¶é»˜è®¤éƒ½åœ¨subviewsæ•°ç»„çš„åé¢ï¼Œæ–°æ·»åŠ çš„æ§ä»¶é»˜è®¤éƒ½æ˜¾ç¤ºåœ¨æœ€ä¸Šé¢\æœ€é¡¶éƒ¨)
- (void)addSubview:(UIView *)view;
//æ·»åŠ ä¸€ä¸ªå­æ§ä»¶(è¢«æŒ¡åœ¨siblingSubviewä¸‹é¢)
- (void)insertSubview:(UIView *)view belowSubview:(UIView *)siblingSubview;
//æ·»åŠ ä¸€ä¸ªå­æ§ä»¶(ç›–åœ¨siblingSubviewä¸Šé¢)
- (void)insertSubview:(UIView *)view aboveSubview:(UIView *)siblingSubview;
//å°†æŸä¸ªå­æ§ä»¶æ‹‰åˆ°æœ€ä¸Šé¢(æœ€é¡¶éƒ¨)æ¥æ˜¾ç¤º
- (void)bringSubviewToFront:(UIView *)view;
//å°†æŸä¸ªå­æ§ä»¶æ‹‰åˆ°æœ€ä¸‹é¢(æœ€åº•éƒ¨)æ¥æ˜¾ç¤º
- (void)sendSubviewToBack:(UIView *)view;
/***ç³»ç»Ÿè‡ªåŠ¨è°ƒç”¨(ç•™ç»™å­ç±»å»å®ç°)***/
//é€šçŸ¥è§†å›¾å·²ç»æ·»åŠ å­è§†å›¾ é»˜è®¤ä¸æ‰§è¡Œä»»ä½•æ“ä½œï¼Œå­ç±»å¯ä»¥é‡å†™
- (void)didAddSubview:(UIView *)subview;
//é€šçŸ¥è§†å›¾æŸä¸ªå­è§†å›¾å³å°†è¢«ç§»é™¤ é»˜è®¤ä¸æ‰§è¡Œä»»ä½•æ“ä½œ å­ç±»å¯ä»¥é‡å†™
- (void)willRemoveSubview:(UIView *)subview;
//é€šçŸ¥å³å°†ç§»åŠ¨åˆ°æ–°çš„çˆ¶è§†å›¾ä¸­
- (void)willMoveToSuperview:(UIView *)newSuperview;
//é€šçŸ¥å·²ç»åˆ°æ–°çˆ¶è§†å›¾
- (void)didMoveToSuperview;
//é€šçŸ¥å³å°†å·²ç§»åŠ¨åˆ°æ–°çš„çª—å£
- (void)willMoveToWindow:(UIWindow *)newWindow;
//é€šçŸ¥å·²ç»ç§»åŠ¨åˆ°æ–°çš„çª—å£
- (void)didMoveToWindow;
/***ç³»ç»Ÿè‡ªåŠ¨è°ƒç”¨***/
//æ˜¯ä¸æ˜¯viewçš„å­æ§ä»¶æˆ–è€…å­æ§ä»¶çš„å­ç©ºé—´(æ˜¯å¦ä¸ºviewçš„åä»£)
- (BOOL)isDescendantOfView:(UIView *)view;  // returns YES for self.
//é€šè¿‡tagè·å¾—å¯¹åº”çš„å­æ§ä»¶(ä¹Ÿå¯ä»¥æ˜¯å­æ§ä»¶çš„å­æ§ä»¶)
- (UIView *)viewWithTag:(NSInteger)tag;     // recursive search. includes self
/***********å¸ƒå±€*********/
// Allows you to perform layout before the drawing cycle happens. -layoutIfNeeded forces layout early
//ä½¿å½“å‰çš„layoutå¼ƒç”¨å½“æ”¶åˆ°å¹¶ä¸”è§¦å‘ä¸€ä¸ªlayoutæ›´æ–°åœ¨ä¸‹ä¸€ä¸ªæ›´æ–°å¾ªç¯ä¸­ è¿›è¡Œæ ‡è®°
- (void)setNeedsLayout;
//ç«‹åˆ»layout ä¸€èˆ¬å’Œä¸Šé¢çš„setNeedsLayouté…åˆä½¿ç”¨
- (void)layoutIfNeeded;
/***ç³»ç»Ÿè‡ªåŠ¨è°ƒç”¨(ç•™ç»™å­ç±»å»å®ç°)***/
//æ§ä»¶çš„frameï¼Œçº¦æŸå‘ç”Ÿæ”¹å˜çš„æ—¶å€™å°±ä¼šè°ƒç”¨ï¼Œä¸€èˆ¬åœ¨è¿™é‡Œé‡å†™å¸ƒå±€å­æ§ä»¶çš„ä½ç½®å’Œå°ºå¯¸
//é‡å†™äº†è¿™ä¸ªæ–¹æ³•åä¸€å®šè¦è°ƒç”¨[super layoutSubviews]
- (void)layoutSubviews;    // override point. called by layoutIfNeeded automatically. As of iOS 6.0, when constraints-based layout is used the base implementation applies the constraints-based layout, otherwise it does nothing.
/*
 layoutSubviewsåœ¨ä»¥ä¸‹æƒ…å†µä¸‹ä¼šè¢«è°ƒç”¨ï¼š
 1ã€initåˆå§‹åŒ–ä¸ä¼šè§¦å‘layoutSubviews ,  ä½† initWithFrame è¿›è¡Œåˆå§‹åŒ–æ—¶ï¼Œå½“rectçš„å€¼ä¸ä¸ºCGRectZeroæ—¶,ä¹Ÿä¼šè§¦å‘.
 2ã€addSubviewä¼šè§¦å‘layoutSubviews.
 3ã€è®¾ç½®viewçš„Frameä¼šè§¦å‘layoutSubviewsï¼Œå½“ç„¶å‰ææ˜¯frameçš„å€¼è®¾ç½®å‰åå‘ç”Ÿäº†å˜åŒ–.
 4ã€æ»šåŠ¨ä¸€ä¸ªUIScrollViewä¼šè§¦å‘layoutSubviews.
 5ã€æ—‹è½¬Screenä¼šè§¦å‘çˆ¶UIViewä¸Šçš„layoutSubviewsäº‹ä»¶.
 6ã€æ”¹å˜ä¸€ä¸ªUIViewå¤§å°çš„æ—¶å€™ä¹Ÿä¼šè§¦å‘çˆ¶UIViewä¸Šçš„layoutSubviewsäº‹ä»¶.
 [1]ã€layoutSubviewså¯¹subviewsé‡æ–°å¸ƒå±€
 [2]ã€layoutSubviewsæ–¹æ³•è°ƒç”¨å…ˆäºdrawRect
 [3]ã€setNeedsLayoutåœ¨receiveræ ‡ä¸Šä¸€ä¸ªéœ€è¦è¢«é‡æ–°å¸ƒå±€çš„æ ‡è®°ï¼Œåœ¨ç³»ç»Ÿrunloopçš„ä¸‹ä¸€ä¸ªå‘¨æœŸè‡ªåŠ¨è°ƒç”¨layoutSubviews
 [4]ã€layoutIfNeededæ–¹æ³•å¦‚å…¶åï¼ŒUIKitä¼šåˆ¤æ–­è¯¥receiveræ˜¯å¦éœ€è¦layout
 [5]ã€layoutIfNeededéå†çš„ä¸æ˜¯superviewé“¾ï¼Œåº”è¯¥æ˜¯subviewsé“¾
 */

/* -layoutMargins returns a set of insets from the edge of the view's bounds that denote a default spacing for laying out content.
 If preservesSuperviewLayoutMargins is YES, margins cascade down the view tree, adjusting for geometry offsets, so that setting
 the left value of layoutMargins on a superview will affect the left value of layoutMargins for subviews positioned close to the
 left edge of their superview's bounds
 If your view subclass uses layoutMargins in its layout or drawing, override -layoutMarginsDidChange in order to refresh your
 view if the margins change.
 On iOS 11.0 and later, please support both user interface layout directions by setting the directionalLayoutMargins property
 instead of the layoutMargins property. After setting the directionalLayoutMargins property, the values in the left and right
 fields of the layoutMargins property will depend on the user interface layout direction.
 */
//iOS8ä¹‹åå¯ä»¥ç”¨ å¯ä»¥ä½¿ç”¨layoutMarginså®šä¹‰viewä¹‹é—´çš„é—´è· è¿™ä¸ªå±æ€§åªå¯¹autolayoutå¸ƒå±€ç”Ÿæ•ˆ
@property (nonatomic) UIEdgeInsets layoutMargins NS_AVAILABLE_IOS(8_0);

/* directionalLayoutMargins.leading is used on the left when the user interface direction is LTR and on the right for RTL.
 Vice versa for directionalLayoutMargins.trailing.
 */
@property (nonatomic) NSDirectionalEdgeInsets directionalLayoutMargins API_AVAILABLE(ios(11.0),tvos(11.0));

//è¿™ä¸ªå±æ€§é»˜è®¤æ˜¯NO å¦‚æœæŠŠå®ƒè®¾ç½®ä¸ºYES layoutMarginsä¼šæ ¹æ®å±å¹•ä¸­ç›¸å…³viewçš„å¸ƒå±€è€Œæ”¹å˜
@property (nonatomic) BOOL preservesSuperviewLayoutMargins NS_AVAILABLE_IOS(8_0); // default is NO - set to enable pass-through or cascading behavior of margins from this viewâ€™s parent to its children

@property (nonatomic) BOOL insetsLayoutMarginsFromSafeArea API_AVAILABLE(ios(11.0),tvos(11.0));  // Default: YES // é»˜è®¤æŒ‰ç…§safeArea insets

//åœ¨æ”¹å˜viewçš„layoutMarginsè¿™ä¸ªå±æ€§æ—¶ï¼Œä¼šè§¦å‘è¿™ä¸ªæ–¹æ³•ï¼Œæˆ‘ä»¬åœ¨è‡ªå·±çš„viewé‡Œé¢å¯ä»¥é‡å†™è¿™ä¸ªæ–¹æ³•æ¥æ•è·layoutMarginsçš„å˜åŒ–ã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¿™ä¸ªæ–¹æ³•ä¸­è§¦å‘drawingå’Œlayoutçš„update
- (void)layoutMarginsDidChange NS_AVAILABLE_IOS(8_0);

/*safeAreaInsets ä¹Ÿå°±æ˜¯ iPhoneX çš„å®‰å…¨åŒºåŸŸ*/
@property (nonatomic,readonly) UIEdgeInsets safeAreaInsets API_AVAILABLE(ios(11.0),tvos(11.0));
/*å½“safeAreaInsetsæ”¹å˜æ—¶ä¼šè°ƒç”¨*/
- (void)safeAreaInsetsDidChange API_AVAILABLE(ios(11.0),tvos(11.0));

/* The edges of this guide are constrained to equal the edges of the view inset by the layoutMargins
 */
@property(readonly,strong) UILayoutGuide *layoutMarginsGuide NS_AVAILABLE_IOS(9_0);

/// This content guide provides a layout area that you can use to place text and related content whose width should generally be constrained to a size that is easy for the user to read. This guide provides a centered region that you can place content within to get this behavior for this view.
@property (nonatomic, readonly, strong) UILayoutGuide *readableContentGuide  NS_AVAILABLE_IOS(9_0);

/* The top of the safeAreaLayoutGuide indicates the unobscured top edge of the view (e.g, not behind
 the status bar or navigation bar, if present). Similarly for the other edges.
 */
@property(nonatomic,readonly,strong) UILayoutGuide *safeAreaLayoutGuide API_AVAILABLE(ios(11.0),tvos(11.0));
@end

@interface UIView(UIViewRendering)
/*
 drawRectæ˜¯å¯¹receiverçš„é‡ç»˜
 setNeedDisplayåœ¨receiveræ ‡ä¸Šä¸€ä¸ªéœ€è¦è¢«é‡æ–°ç»˜å›¾çš„æ ‡è®°ï¼Œåœ¨ä¸‹ä¸€ä¸ªdrawå‘¨æœŸè‡ªåŠ¨é‡ç»˜ï¼Œiphone deviceçš„åˆ·æ–°é¢‘ç‡æ˜¯60hzï¼Œä¹Ÿå°±æ˜¯1/60ç§’åé‡ç»˜
 */
//æ¸²æŸ“ é‡å†™æ­¤æ–¹æ³• æ‰§è¡Œé‡ç»˜
- (void)drawRect:(CGRect)rect;
//éœ€è¦é‡æ–°æ¸²æŸ“ æ ‡è®°ä¸ºéœ€è¦é‡ç»˜ å¼‚æ­¥è°ƒç”¨drawRect
- (void)setNeedsDisplay;
//éœ€è¦é‡æ–°æ¸²æŸ“åœ¨æŸä¸€å—åŒºåŸŸ
- (void)setNeedsDisplayInRect:(CGRect)rect;


//YESï¼šè¶…å‡ºæ§ä»¶è¾¹æ¡†èŒƒå›´çš„å†…å®¹éƒ½å‰ªæ‰
@property(nonatomic)                 BOOL              clipsToBounds;              // When YES, content and subviews are clipped to the bounds of the view. Default is NO.
//èƒŒæ™¯è‰²
@property(nonatomic,copy)            UIColor          *backgroundColor UI_APPEARANCE_SELECTOR; // default is nil. Can be useful with the appearance proxy on custom UIView subclasses.
//é€æ˜åº¦(0.0~1.0)
@property(nonatomic)                 CGFloat          alpha;                      // animatable. default is 1.0
//YES:ä¸é€æ˜ NO:é€æ˜
/*
 å†³å®šè¯¥æ¶ˆæ¯æ¥æ”¶è€…(UIView instance)æ˜¯å¦è®©å…¶è§†å›¾ä¸é€æ˜,ç”¨å¤„åœ¨äºç»™ç»˜å›¾ç³»ç»Ÿæä¾›ä¸€ä¸ªæ€§èƒ½ä¼˜åŒ–å¼€å…³ã€‚
 insertDemoTwo.opaque = NO;
 è¯¥å€¼ä¸ºYES, é‚£ä¹ˆç»˜å›¾åœ¨ç»˜åˆ¶è¯¥è§†å›¾çš„æ—¶å€™æŠŠæ•´ä¸ªè§†å›¾å½“ä½œä¸é€æ˜å¯¹å¾…ã€‚ä¼˜åŒ–ç»˜å›¾è¿‡ç¨‹å¹¶æå‡ç³»ç»Ÿæ€§èƒ½ï¼›ä¸ºäº†æ€§èƒ½æ–¹é¢çš„è€ƒé‡ï¼Œé»˜è®¤è¢«ç½®ä¸ºYESã€‚
 è¯¥å€¼ä¸ºNO,ï¼Œä¸å»åšä¼˜åŒ–æ“ä½œã€‚
 ä¸€ä¸ªä¸é€æ˜è§†å›¾éœ€è¦æ•´ä¸ªè¾¹ç•Œé‡Œé¢çš„å†…å®¹éƒ½æ˜¯ä¸é€æ˜ã€‚åŸºäºè¿™ä¸ªåŸå› ï¼Œopaqueè®¾ç½®ä¸ºYESï¼Œè¦æ±‚å¯¹åº”çš„alphaå¿…é¡»ä¸º1.0ã€‚å¦‚æœä¸€ä¸ªUIViewå®ä¾‹opaqueè¢«è®¾ç½®ä¸ºYES, è€ŒåŒæ—¶å®ƒåˆæ²¡æœ‰å®Œå…¨å¡«å……å®ƒçš„è¾¹ç•Œ(bounds),æˆ–è€…å®ƒåŒ…å«äº†æ•´ä¸ªæˆ–éƒ¨åˆ†çš„é€æ˜çš„å†…å®¹è§†å›¾ï¼Œé‚£ä¹ˆå°†ä¼šå¯¼è‡´æœªçŸ¥çš„ç»“æœã€‚
 å› æ­¤ï¼Œå¦‚æœè§†å›¾éƒ¨åˆ†æˆ–å…¨éƒ¨æ”¯æŒé€æ˜ï¼Œé‚£ä¹ˆä½ å¿…é¡»æŠŠopaqueè¿™ä¸ªå€¼è®¾ç½®ä¸ºNO.
 */
@property(nonatomic,getter=isOpaque) BOOL              opaque;                     // default is YES. opaque views must fill their entire bounds or the results are undefined. the active CGContext in drawRect: will not have been cleared and may have non-zeroed pixels

/*YES:è‡ªåŠ¨çš„æ¸…é™¤ä¹‹å‰çš„æ¸²æŸ“(ç»˜åˆ¶å‰æ˜¯å¦æ¸…å±)  NO:ä¸è‡ªåŠ¨æ¸…é™¤   default is YES
 insertDemoOne.clearsContextBeforeDrawing = YES;
 æé«˜æç”»æ€§èƒ½ï¼ˆç‰¹åˆ«æ˜¯åœ¨æ»šåŠ¨è¿‡ç¨‹ï¼‰çš„å¦ä¸€ä¸ªæ–¹æ³•æ˜¯å°†è§†å›¾çš„clearsContextBeforeDrawingå±æ€§è®¾ç½®ä¸ºNOã€‚å½“è¿™ä¸ªå±æ€§è¢«è®¾ç½®ä¸ºYESæ—¶ï¼ŒUIKItä¼šåœ¨è°ƒç”¨drawRect:æ–¹æ³•ä¹‹å‰ï¼ŒæŠŠå³å°†è¢«è¯¥æ–¹æ³•æ›´æ–°çš„åŒºåŸŸå¡«å……ä¸ºé€æ˜çš„é»‘è‰²ã€‚å°†è¿™ä¸ªå±æ€§è®¾ç½®ä¸ºNOå¯ä»¥å–æ¶ˆç›¸åº”çš„å¡«å……æ“ä½œï¼Œè€Œç”±åº”ç”¨ç¨‹åºè´Ÿè´£å®Œå…¨é‡ç”»ä¼ ç»™drawRect:æ–¹æ³•çš„æ›´æ–°çŸ©å½¢ä¸­çš„éƒ¨ã€‚è¿™æ ·çš„ä¼˜åŒ–åœ¨æ»šåŠ¨è¿‡ç¨‹ä¸­é€šå¸¸æ˜¯ä¸€ä¸ªå¥½çš„æŠ˜è¡·ã€‚*/
@property(nonatomic)                 BOOL              clearsContextBeforeDrawing; // default is YES. ignored for opaque views. for non-opaque views causes the active CGContext in drawRect: to be pre-filled with transparent pixels
//YES:éšè— NO:æ˜¾ç¤º
@property(nonatomic,getter=isHidden) BOOL              hidden;                     // default is NO. doesn't check superviews
//å†…å®¹æ¨¡å¼ä¸»è¦ç”¨äºæŒ‡å®šæ§ä»¶å†…å®¹ï¼ˆæ³¨æ„ä¸æ˜¯å­æ§ä»¶ï¼‰å¦‚ä½•å¡«å……ï¼Œä¸€èˆ¬UIImageViewç»å¸¸ä½¿ç”¨ï¼Œé»˜è®¤ä¸ºUIViewContentModeScaleToFill
@property(nonatomic)                 UIViewContentMode     contentMode;                // default is UIViewContentModeScaleToFill
/*http://blog.csdn.net/andyddd/article/details/7574885//è§†å›¾æ‹‰ä¼¸å’Œç¼©ç•¥ ï¼ˆ0.0-1.0ä¹‹é—´ï¼‰iOS6.0å¼ƒç”¨ è¢«-[UIImage resizableImageWithCapInsets:]ä»£æ›¿  imageDemo.image = [UIImage imageNamed:@"demo.png"];
 [imageDemo setContentStretch:CGRectMake(50.0/100.0, 75.0/150.0, 10.0/100.0, 10.0/150.0)];
 å½“demo.pngå¤§äºimageDemoçš„å¤§å°æ—¶ï¼Œå°±ç¼©å°ã€‚
 å½“demo.pngå°äºimageDemoçš„å¤§å°æ—¶ï¼Œå°±æ”¾å¤§ã€‚*/
@property(nonatomic)                 CGRect            contentStretch NS_DEPRECATED_IOS(3_0,6_0); // animatable. default is unit rectangle { {0,0} {1,1} }. Now deprecated: please use -[UIImage resizableImageWithCapInsets:] to achieve the same effect.
//é®ç½©View
@property(nonatomic,retain)          UIView          *maskView NS_AVAILABLE_IOS(8_0);

/*
 -tintColor always returns a color. The color returned is the first non-default value in the receiver's superview chain (starting with itself).
 If no non-default value is found, a system-defined color is returned.
 If this view's -tintAdjustmentMode returns Dimmed, then the color that is returned for -tintColor will automatically be dimmed.
 If your view subclass uses tintColor in its rendering, override -tintColorDidChange in order to refresh the rendering if the color changes.
 */
//è‰²è°ƒé¢œè‰²
@property(nonatomic,retain) UIColor *tintColor NS_AVAILABLE_IOS(7_0);

/*
 -tintAdjustmentMode always returns either UIViewTintAdjustmentModeNormal or UIViewTintAdjustmentModeDimmed. The value returned is the first non-default value in the receiver's superview chain (starting with itself).
 If no non-default value is found, UIViewTintAdjustmentModeNormal is returned.
 When tintAdjustmentMode has a value of UIViewTintAdjustmentModeDimmed for a view, the color it returns from tintColor will be modified to give a dimmed appearance.
 When the tintAdjustmentMode of a view changes (either the view's value changing or by one of its superview's values changing), -tintColorDidChange will be called to allow the view to refresh its rendering.
 */
//è‰²è°ƒè°ƒæ•´æ¨¡å¼
@property(nonatomic) UIViewTintAdjustmentMode tintAdjustmentMode NS_AVAILABLE_IOS(7_0);

/*
 The -tintColorDidChange message is sent to appropriate subviews of a view when its tintColor is changed by client code or to subviews in the view hierarchy of a view whose tintColor is implicitly changed when its superview or tintAdjustmentMode changes.
 */
//å½“tintColorå±æ€§æ”¹å˜æ—¶ä¼šè§¦å‘æ–¹æ³•çš„è°ƒç”¨ iOS7ä¹‹åå¯ç”¨
- (void)tintColorDidChange NS_AVAILABLE_IOS(7_0);

@end

@interface UIView(UIViewAnimation)
//ç±»æ–¹æ³•  å¼€å§‹ä¸€ä¸ªåŠ¨ç”» 4.0ä»¥åä¸æ¨èä½¿ç”¨
+ (void)beginAnimations:(NSString *)animationID context:(void *)context;  // additional context info passed to will start/did stop selectors. begin/commit can be nested
//ç»“æŸåŠ¨ç”» ç±»ä¼¼æ•°æ®åº“çš„äº‹ç‰©å¤„ç†
+ (void)commitAnimations;                                                 // starts up any animations when the top level animation is commited

// no getters. if called outside animation block, these setters have no effect.
//è®¾ç½®åŠ¨ç”»å§”æ‰˜
+ (void)setAnimationDelegate:(id)delegate;                          // default = nil
//å½“åŠ¨ç”»æ‰§è¡Œç»“æŸæ—¶ æ‰§è¡Œselector
+ (void)setAnimationWillStartSelector:(SEL)selector;                // default = NULL. -animationWillStart:(NSString *)animationID context:(void *)context
+ (void)setAnimationDidStopSelector:(SEL)selector;                  // default = NULL. -animationDidStop:(NSString *)animationID finished:(NSNumber *)finished context:(void *)context
//è®¾ç½®åŠ¨ç”»æ—¶é—´  æ—¶é—´å‚æ•°ä¸ºdoubleç±»å‹ é»˜è®¤æ˜¯0.2ç§’
+ (void)setAnimationDuration:(NSTimeInterval)duration;              // default = 0.2
//è®¾ç½®åŠ¨ç”»å»¶è¿Ÿæ—¶é—´
+ (void)setAnimationDelay:(NSTimeInterval)delay;                    // default = 0.0
//è®¾ç½®åœ¨åŠ¨ç”»å—å†…éƒ¨åŠ¨ç”»å±æ€§æ”¹å˜çš„å¼€å§‹æ—¶é—´
+ (void)setAnimationStartDate:(NSDate *)startDate;                  // default = now ([NSDate date])
//è®¾ç½®åŠ¨ç”»çš„æ—‹è½¬æ›²åº¦å˜åŒ–
+ (void)setAnimationCurve:(UIViewAnimationCurve)curve;              // default = UIViewAnimationCurveEaseInOut
//è®¾ç½®åŠ¨ç”»åœ¨åŠ¨ç”»æ¨¡å—ä¸­é‡å¤æ¬¡æ•°
+ (void)setAnimationRepeatCount:(float)repeatCount;                 // default = 0.0.  May be fractional
//è®¾ç½®åŠ¨ç”»å—ä¸­çš„åŠ¨ç”»æ•ˆæœæ˜¯å¦è‡ªåŠ¨æ’­æ”¾
+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses;    // default = NO. used if repeat count is non-zero
//è®¾ç½®åŠ¨ç”»æ˜¯å¦ä»å½“å‰çŠ¶æ€å¼€å§‹æ’­æ”¾
+ (void)setAnimationBeginsFromCurrentState:(BOOL)fromCurrentState;  // default = NO. If YES, the current view position is always used for new animations -- allowing animations to "pile up" on each other. Otherwise, the last end state is used for the animation (the default).
/* åœ¨åŠ¨ç”»å—è®¾ç½®è¿‡æ¸¡æ•ˆæœ transitionæŠŠä¸€ä¸ªè¿‡æ¸¡æ•ˆæœåº”ç”¨åˆ°è§†å›¾ä¸­  viewéœ€è¦è¿‡æ¸¡çš„è§†å›¾å¯¹è±¡  cache
å¦‚æœæ˜¯YESï¼Œé‚£ä¹ˆåœ¨å¼€å§‹å’Œç»“æŸå›¾ç‰‡è§†å›¾æ¸²æŸ“ä¸€æ¬¡å¹¶åœ¨åŠ¨ç”»ä¸­åˆ›å»ºå¸§ï¼›å¦åˆ™ï¼Œè§†å›¾å°†ä¼šåœ¨æ¯ä¸€å¸§éƒ½æ¸²æŸ“ã€‚ä¾‹å¦‚ç¼“å­˜ï¼Œä½ ä¸éœ€è¦åœ¨è§†å›¾è½¬å˜ä¸­ä¸åœçš„æ›´æ–°ï¼Œä½ åªéœ€è¦ç­‰åˆ°è½¬æ¢å®Œæˆå†å»æ›´æ–°è§†å›¾ã€‚
1ã€å¼€å§‹ä¸€ä¸ªåŠ¨ç”»å—ã€‚
2ã€åœ¨å®¹å™¨è§†å›¾ä¸­è®¾ç½®è½¬æ¢ã€‚
3ã€åœ¨å®¹å™¨è§†å›¾ä¸­ç§»é™¤å­è§†å›¾ã€‚
4ã€åœ¨å®¹å™¨è§†å›¾ä¸­æ·»åŠ å­è§†å›¾ã€‚
5ã€ç»“æŸåŠ¨ç”»å—ã€‚
 */
+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache;  // current limitation - only one per begin/commit block
//è®¾ç½®æ˜¯å¦å¼€å¯åŠ¨ç”» é»˜è®¤YES
+ (void)setAnimationsEnabled:(BOOL)enabled;                         // ignore any attribute changes while set.
#if UIKIT_DEFINE_AS_PROPERTIES
@property(class, nonatomic, readonly) BOOL areAnimationsEnabled;
#else
//éªŒè¯åŠ¨ç”»æ˜¯å¦å¼€å¯ YES:å¼€å¯ NO:å…³é—­
+ (BOOL)areAnimationsEnabled;
#endif
//å…ˆæ£€æŸ¥åŠ¨ç”»å½“å‰æ˜¯å¦å¯ç”¨ï¼Œç„¶åç¦æ­¢åŠ¨ç”»ï¼Œæ‰§è¡Œblockå†…æ–¹æ³•ï¼Œæœ€åé‡æ–°å¯ç”¨åŠ¨ç”»ã€‚å®ƒå¹¶ä¸ä¼šé˜»å¡åŸºäºCoreAnimationçš„åŠ¨ç”»
+ (void)performWithoutAnimation:(void (NS_NOESCAPE ^)(void))actionsWithoutAnimation NS_AVAILABLE_IOS(7_0);

#if UIKIT_DEFINE_AS_PROPERTIES
@property(class, nonatomic, readonly) NSTimeInterval inheritedAnimationDuration NS_AVAILABLE_IOS(9_0);
#else
+ (NSTimeInterval)inheritedAnimationDuration NS_AVAILABLE_IOS(9_0);
#endif

@end

@interface UIView(UIViewAnimationWithBlocks)
//åŠ¨ç”»æ•ˆæœå¤„ç†å— durationåŠ¨ç”»æ—¶é—´ delayå»¶è¿Ÿæ—¶é—´ optionsåŠ¨ç”»å‚æ•° animationsåŠ¨ç”»æ•ˆæœå— å¯ä»¥è®¾ç½®å±æ€§å¦‚ä¸‹ï¼šframe bounds center
//transform alpha backgroundColor contentStretch  completionå®Œæˆåéœ€è¦åšçš„æ“ä½œ
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);
//æ²¡æœ‰å»¶è¿Ÿæ—¶é—´ æ²¡æœ‰åŠ¨ç”»å‚æ•° optionsé»˜è®¤ä¸º0
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); // delay = 0.0, options = 0
//åŠ¨ç”»æ•ˆæœå¤„ç†å— delay = 0.0, options = 0, completion = NULL
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations NS_AVAILABLE_IOS(4_0); // delay = 0.0, options = 0, completion = NULL

/* Performs `animations` using a timing curve described by the motion of a spring. When `dampingRatio` is 1, the animation will smoothly decelerate to its final model values without oscillating. Damping ratios less than 1 will oscillate more and more before coming to a complete stop. You can use the initial spring velocity to specify how fast the object at the end of the simulated spring was moving before it was attached. It's a unit coordinate system, where 1 is defined as travelling the total animation distance in a second. So if you're changing an object's position by 200pt in this animation, and you want the animation to behave as if the object was moving at 100pt/s before the animation started, you'd pass 0.5. You'll typically want to pass 0 for the velocity. */
//å‚è€ƒ http://www.tuicool.com/articles/ZR7nYv  http://www.woshipm.com/ucd/85600.html
// Spring(å¼¹ç°§) Animationçš„API æ¯”ä¸€èˆ¬åŠ¨ç”»å¤šäº†ä¸¤ä¸ªå‚æ•° usingSpringWithDamping(èŒƒå›´ä¸º0.0f~1.0f)ï¼Œæ•°å€¼è¶Šå°å¼¹ç°§çš„éœ‡åŠ¨çš„æ•ˆæœè¶Šæ˜æ˜¾
// initialSpringVelocity è¡¨ç¤ºåˆå§‹é€Ÿåº¦ï¼Œæ•°å€¼è¶Šå¤§ä¸€å¼€å§‹ç§»åŠ¨è¶Šå¿«
// dampingRatio è®¾ç½®å¼¹ç°§çš„é˜»å°¼æ¯”ä¾‹
// velocity è®¾ç½®å¼¹ç°§çš„æœ€åˆé€Ÿåº¦
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);



/* [UIView transitionWithView:_redView
 duration:2.0
 options:UIViewAnimationOptionTransitionCurlDown
 animations:^{
 [_blackView removeFromSuperview];
 [_redView addSubview:_blackView];
 } completion:^(BOOL finished) {
 _redView.backgroundColor = [UIColor brownColor];
 }];***/
//å›½åº¦åŠ¨ç”»æ•ˆæœå—
+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);

//è§†å›¾ä¹‹é—´åˆ‡æ¢çš„å›½åº¦åŠ¨ç”»æ•ˆæœå—
+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); // toView added to fromView.superview, fromView removed from its superview

/* Performs the requested system-provided animation on one or more views. Specify addtional animations in the parallelAnimations block. These additional animations will run alongside the system animation with the same timing and duration that the system animation defines/inherits. Additional animations should not modify properties of the view on which the system animation is being performed. Not all system animations honor all available options.
 */
//åœ¨ä¸€ç»„è§†å›¾ä¸Šæ‰§è¡ŒæŒ‡å®šçš„ç³»ç»ŸåŠ¨ç”»ï¼Œå¹¶å¯ä»¥å¹¶è¡Œè‡ªå®šä¹‰åŠ¨ç”»ã€‚å…¶ä¸­parallelAnimationså°±æ˜¯ä¸ç³»ç»ŸåŠ¨ç”»å¹¶è¡Œçš„è‡ªå®šä¹‰åŠ¨ç”»
+ (void)performSystemAnimation:(UISystemAnimation)animation onViews:(NSArray *)views options:(UIViewAnimationOptions)options animations:(void (^)(void))parallelAnimations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);

@end

@interface UIView (UIViewKeyframeAnimations)
/***********
 [UIViewanimateKeyframesWithDuration:2.0delay:0options:UIViewKeyframeAnimationOptionRepeatanimations:^{
 
 _blackView.frame = CGRectMake(30, 30, 50, 50);
 [UIView addKeyframeWithRelativeStartTime:0.5 relativeDuration:0 animations:^{
 _redView.frame = CGRectMake(50, 50, 50, 50);
 }];
 
 
 } completion:^(BOOL finished) {
 
 _redView.frame= CGRectMake(50, 50, 100, 100);;
 _blackView.frame = CGRectMake(30, 30, 80, 80);
 
 }];
 
 */

// ä¸ºå½“å‰è§†å›¾åˆ›å»ºä¸€ä¸ªå¯ä»¥ç”¨äºè®¾ç½®åŸºæœ¬å…³é”®å¸§åŠ¨ç”»çš„blockå¯¹è±¡ä»IOS7å¼€å§‹ä½¿ç”¨
// è¿™é‡Œè¯´ä¸€ä¸‹å‚æ•°ï¼Œç¬¬ä¸€ä¸ªframeStartTimeå…¶å®æ˜¯ä¸ªå€æ•°ä»0åˆ°1ï¼Œå‡è®¾ä¸€ä¸ªåŠ¨ç”»æŒç»­çš„æ—¶é—´æ˜¯2ç§’
// è®¾ç½®frameStartTimeä¸º0.5ï¼Œé‚£ä¹ˆåé¢è®¾ç½®çš„åŠ¨ç”»ï¼Œå°†ä¼šåœ¨æ•´ä½“åŠ¨ç”»æ‰§è¡Œ1ç§’åå¼€å§‹æ‰§è¡Œ
// ç¬¬äºŒä¸ªå‚æ•°frameDurationåŒç¬¬ä¸€ä¸ªï¼Œæ˜¯æŒ‡åŠ¨ç”»æŒç»­æ—¶é—´
// ç¬¬å››ä¸ªæ˜¯ä¸€ä¸ªblockå¯¹è±¡ï¼Œé‡Œé¢å°±æ˜¯ä½ è®¾ç½®çš„æ‰€è¦æ‰§è¡Œçš„åŠ¨ç”»ï¼Œæ— å‚æ•°å’Œè¿”å›å€¼
// è¿™ä¸ªæ–¹æ³•å¯ä»¥ç»“åˆ  + (Class)layerClass ä½¿ç”¨
+ (void)animateKeyframesWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewKeyframeAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);

// æŒ‡å®šä¸€ä¸ªå…³é”®å¸§çš„å•ä¸ªè´çš„æ—¶é—´å’ŒåŠ¨ç”» iOS7åå¯ç”¨
// frameStartTimeæ˜¯ä¸€ä¸ªå€æ•°ä»0åˆ°1ï¼Œå‡è®¾ä¸€ä¸ªåŠ¨ç”»æŒç»­çš„æ—¶é—´æ˜¯2ç§’ è®¾ç½®frameStartTimeä¸º0.5é‚£ä¹ˆåé¢è®¾ç½®çš„åŠ¨ç”»å°†ä¼šåœ¨æ•´ä½“åŠ¨ç”»æ‰§è¡Œ1ç§’åå¼€å§‹
// frameDurationæ˜¯æŒ‡åŠ¨ç”»æŒç»­æ—¶é—´
+ (void)addKeyframeWithRelativeStartTime:(double)frameStartTime relativeDuration:(double)frameDuration animations:(void (^)(void))animations NS_AVAILABLE_IOS(7_0); // start time and duration are values between 0.0 and 1.0 specifying time and duration relative to the overall time of the keyframe animation

@end

@interface UIView (UIViewGestureRecognizers)

@property(nonatomic,copy) NSArray *gestureRecognizers NS_AVAILABLE_IOS(3_2);//æ‰‹åŠ¿è¯†åˆ«å™¨
/*
 UIKit ä¸­UIGestureRecognizerç±»çš„å­ç±»ç³»åˆ—å¦‚ä¸‹ï¼š
 UITapGestureRecognizer â€“ â€œè½»å‡»â€æ‰‹åŠ¿ã€‚å¯ä»¥é…ç½®ä¸ºâ€œå•å‡»â€å’Œâ€œè¿å‡»â€çš„è¯†åˆ«ã€‚
 UIPinchGestureRecognizer â€“â€œæåˆâ€æ‰‹åŠ¿ã€‚è¯¥æ‰‹åŠ¿é€šå¸¸ç”¨äºç¼©æ”¾è§†å›¾æˆ–æ”¹å˜å¯è§†ç»„ä»¶çš„å¤§å°ã€‚
 UIPanGestureRecognizer â€“ â€œå¹³ç§»â€æ‰‹åŠ¿ã€‚è¯†åˆ«æ‹–æ‹½æˆ–ç§»åŠ¨åŠ¨ä½œã€‚
 UISwipeGestureRecognizer â€“ â€œè½»æ‰«â€æ‰‹åŠ¿ã€‚å½“ç”¨æˆ·ä»å±å¹•ä¸Šåˆ’è¿‡æ—¶è¯†åˆ«ä¸ºè¯¥æ‰‹åŠ¿ã€‚å¯ä»¥æŒ‡å®šè¯¥åŠ¨ä½œçš„æ–¹å‘ï¼ˆä¸Šã€ä¸‹ã€å·¦ã€å³ï¼‰ã€‚
 UIRotationGestureRecognizer â€“ â€œè½¬åŠ¨â€æ‰‹åŠ¿ã€‚ç”¨æˆ·ä¸¤æŒ‡åœ¨å±å¹•ä¸Šåšç›¸å¯¹ç¯å½¢è¿åŠ¨ã€‚
 UILongPressGestureRecognizer â€“ â€œé•¿æŒ‰â€æ‰‹åŠ¿ã€‚ä½¿ç”¨1æŒ‡æˆ–å¤šæŒ‡è§¦æ‘¸å±å¹•å¹¶ä¿æŒä¸€å®šæ—¶é—´ã€‚
 */
//ç»™VIewæ·»åŠ ä¸€ä¸ªæ‰‹åŠ¿
- (void)addGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2);
//ç§»é™¤VIewçš„æ‰‹åŠ¿
- (void)removeGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2);

// called when the recognizer attempts to transition out of UIGestureRecognizerStatePossible if a touch hit-tested to this view will be cancelled as a result of gesture recognition
// returns YES by default. return NO to cause the gesture recognizer to transition to UIGestureRecognizerStateFailed
// subclasses may override to prevent recognition of particular gestures. for example, UISlider prevents swipes parallel to the slider that start in the thumb
/*
 æ‰‹åŠ¿è¯†åˆ«å¤„ç†æ–¹å¼åœ¨gesture recognizerè§†å›¾è½¬å‡ºã€ŠUIGestureRecognizerStatePossibleã€‹çŠ¶æ€æ—¶è°ƒç”¨ï¼Œ
 å¦‚æœè¿”å›NO,åˆ™è½¬æ¢åˆ°ã€ŠUIGestureRecognizerStateFailedã€‹;
 å¦‚æœè¿”å›YES,åˆ™ç»§ç»­è¯†åˆ«è§¦æ‘¸åºåˆ—.(é»˜è®¤æƒ…å†µä¸‹ä¸ºYES)ã€‚
 [insertDemoOne gestureRecognizerShouldBegin:demoGesture];
 */
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer NS_AVAILABLE_IOS(6_0);

@end

@interface UIView (UIViewMotionEffects)

/*! Begins applying `effect` to the receiver. The effect's emitted keyPath/value pairs will be
 applied to the view's presentation layer.
 
 Animates the transition to the motion effect's values using the present UIView animation
 context. */
/*
 å½“ä½ æ‰“å¼€è£…æœ‰iOS7ä»¥ä¸Šçš„iPhoneä¸»å±ï¼Œé»˜è®¤çš„èƒŒæ™¯æ˜¯ä¸€å¹…è“è‰²çš„æ˜Ÿç©ºå›¾ç‰‡ã€‚å½“ä¸Šä¸‹å·¦å³ç¿»è½¬iPhoneæ—¶ï¼Œæœ‰è¶£çš„æ•ˆæœå°†ä¼šå‡ºç°ï¼Œæ˜Ÿç©ºèƒŒæ™¯ä¹Ÿä¼šæ²¿ç€å„ä¸ªæ–¹å‘å‘ç”Ÿä½ç§»ï¼Œè¿™ä¸ä¸»å±ä¸Šçš„å„ä¸ªApp Iconå½¢æˆäº†ä¸€ç§ç‹¬ç‰¹çš„è§†å·®æ•ˆæœã€‚
 //UIMotionEffect
 1. UIInterpolatingMotionEffect
 
 UIInterpolatingMotionEffectæ˜¯UIMotionEffectçš„å­ç±»ï¼Œè™½ç„¶æ‰©å±•ä¹Ÿä¸å¤æ‚ï¼Œæä¾›çš„æ–¹æ³•ä¹Ÿå¾ˆç®€å•ï¼Œä½†åœ¨å¾ˆå¤šåœºæ™¯ä¸‹å¯ä»¥æ¯”è¾ƒç›´æ¥å’Œæ–¹ä¾¿çš„æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ã€‚
 
 å®ƒæœ‰4ä¸ªproperty:
 
 1.keyPathï¼Œå·¦å³ç¿»è½¬å±å¹•å°†è¦å½±å“åˆ°çš„å±æ€§ï¼Œæ¯”å¦‚center.xã€‚
 
 2.typeï¼ˆUIInterpolatingMotionEffectTypeç±»å‹ï¼‰ï¼Œè§‚å¯Ÿè€…è§†è§’ï¼Œä¹Ÿå°±æ˜¯å±å¹•å€¾æ–œçš„æ–¹å¼ï¼Œç›®å‰åŒºåˆ†æ°´å¹³å’Œå‚ç›´ä¸¤ç§æ–¹å¼ã€‚
 
 3&amp;4.minimumRelativeValueå’ŒmaximumRelativeValueï¼ŒkeyPathå¯¹åº”çš„å€¼çš„å˜åŒ–èŒƒå›´ï¼Œæ³¨æ„è¿™ä¸ªæ˜¯idç±»å‹ã€‚minå¯¹åº”æœ€å°çš„offsetï¼Œmaxå¯¹åº”æœ€å¤§çš„offsetã€‚
 
 UIInterpolatingMotionEffect * xEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.x" type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis];
 xEffect.minimumRelativeValue =  [NSNumber numberWithFloat:-40.0];
 xEffect.maximumRelativeValue = [NSNumber numberWithFloat:40.0];
 [targetView addMotionEffect:xEffect];
 å‚è€ƒè‡ªhttp://www.cocoachina.com/ios/20150121/10967.html
 */
- (void)addMotionEffect:(UIMotionEffect *)effect NS_AVAILABLE_IOS(7_0);

/*! Stops applying `effect` to the receiver. Any affected presentation values will animate to
 their post-removal values using the present UIView animation context. */
//ç§»é™¤ä¸€ä¸ªUIMotionEffect
- (void)removeMotionEffect:(UIMotionEffect *)effect NS_AVAILABLE_IOS(7_0);
//åŒ…å«çš„UIMotionEffect
@property (copy, nonatomic) NSArray *motionEffects NS_AVAILABLE_IOS(7_0);

@end


//
// UIView Constraint-based Layout Support
//

typedef NS_ENUM(NSInteger, UILayoutConstraintAxis) {
    UILayoutConstraintAxisHorizontal = 0,
    UILayoutConstraintAxisVertical = 1
};

// Installing Constraints

/* A constraint is typically installed on the closest common ancestor of the views involved in the constraint.
 It is required that a constraint be installed on _a_ common ancestor of every view involved.  The numbers in a constraint are interpreted in the coordinate system of the view it is installed on.  A view is considered to be an ancestor of itself.
 */
@interface UIView (UIConstraintBasedLayoutInstallingConstraints)
//è§†å›¾å¸ƒå±€çº¦æŸ
- (NSArray *)constraints NS_AVAILABLE_IOS(6_0);

//è§†å›¾å¸ƒå±€æ·»åŠ ä¸€ä¸ªçº¦æŸ
- (void)addConstraint:(NSLayoutConstraint *)constraint NS_AVAILABLE_IOS(6_0); // This method will be deprecated in a future release and should be avoided.  Instead, set NSLayoutConstraint's active property to YES.
//è§†å›¾å¸ƒå±€ä¸Šæ·»åŠ å¤šä¸ªçº¦æŸ
- (void)addConstraints:(NSArray *)constraints NS_AVAILABLE_IOS(6_0); // This method will be deprecated in a future release and should be avoided.  Instead use +[NSLayoutConstraint activateConstraints:].
//ç§»é™¤è§†å›¾å¸ƒå±€ä¸€ä¸ªçº¦æŸ
- (void)removeConstraint:(NSLayoutConstraint *)constraint NS_AVAILABLE_IOS(6_0); // This method will be deprecated in a future release and should be avoided.  Instead set NSLayoutConstraint's active property to NO.
//ç§»é™¤è§†å›¾å¸ƒå±€ä¸Šå¤šä¸ªçº¦æŸ
- (void)removeConstraints:(NSArray *)constraints NS_AVAILABLE_IOS(6_0); // This method will be deprecated in a future release and should be avoided.  Instead use +[NSLayoutConstraint deactivateConstraints:].
@end

// Core Layout Methods

/* To render a window, the following passes will occur, if necessary.
 
 update constraints
 layout
 display
 
 Please see the conceptual documentation for a discussion of these methods.
 */

@interface UIView (UIConstraintBasedLayoutCoreMethods)
//è°ƒç”¨æ–°çš„è§†å›¾å¸ƒå±€è‡ªåŠ¨è§¦å‘,æ›´æ–°è§†å›¾å¸ƒå±€ä¸Šçš„çº¦æŸ
- (void)updateConstraintsIfNeeded NS_AVAILABLE_IOS(6_0); // Updates the constraints from the bottom up for the view hierarchy rooted at the receiver. UIWindow's implementation creates a layout engine if necessary first.
//æ›´æ–°è‡ªå®šä¹‰è§†å›¾å¸ƒå±€ é‡å†™è¿™ä¸ªæ–¹æ³•å»é€‚åº”ç‰¹æ®Šçš„çº¦æŸåœ¨æ›´æ–°çº¦æŸæœŸé—´
- (void)updateConstraints NS_AVAILABLE_IOS(6_0); // Override this to adjust your special constraints during a constraints update pass
//åˆ¤æ–­è§†å›¾æ˜¯å¦éœ€è¦æ›´æ–°çº¦æŸ
- (BOOL)needsUpdateConstraints NS_AVAILABLE_IOS(6_0);
//è®¾ç½®è§†å›¾å¸ƒå±€æ˜¯å¦éœ€è¦æ›´æ–°çº¦æŸ
- (void)setNeedsUpdateConstraints NS_AVAILABLE_IOS(6_0);
@end

// Compatibility and Adoption

@interface UIView (UIConstraintBasedCompatibility)

/* by default, the autoresizing mask on a view gives rise to constraints that fully determine the view's position.  Any constraints you set on the view are likely to conflict with autoresizing constraints, so you must turn off this property first. IB will turn it off for you.
 */
//æ ‡ç¤ºæ˜¯å¦è‡ªåŠ¨éµå¾ªè§†å›¾å¸ƒå±€çº¦æŸ é»˜è®¤æ˜¯YES
- (BOOL)translatesAutoresizingMaskIntoConstraints NS_AVAILABLE_IOS(6_0); // Default YES
//è®¾ç½®æ˜¯å¦è‡ªåŠ¨éµå¾ªè§†å›¾å¸ƒå±€çº¦æŸ
- (void)setTranslatesAutoresizingMaskIntoConstraints:(BOOL)flag NS_AVAILABLE_IOS(6_0);

/* constraint-based layout engages lazily when someone tries to use it (e.g., adds a constraint to a view).  If you do all of your constraint set up in -updateConstraints, you might never even receive updateConstraints if no one makes a constraint.  To fix this chicken and egg problem, override this method to return YES if your view needs the window to use constraint-based layout.
 */
//è¿”å›æ˜¯éµå¾ªè‡ªå®šä¹‰è§†å›¾å¸ƒå±€çº¦æŸ
+ (BOOL)requiresConstraintBasedLayout NS_AVAILABLE_IOS(6_0);

@end

// Separation of Concerns

@interface UIView (UIConstraintBasedLayoutLayering)

/* Constraints do not actually relate the frames of the views, rather they relate the "alignment rects" of views.  This is the same as the frame unless overridden by a subclass of UIView.  Alignment rects are the same as the "layout rects" shown in Interface Builder 3.  Typically the alignment rect of a view is what the end user would think of as the bounding rect around a control, omitting ornamentation like shadows and engraving lines.  The edges of the alignment rect are what is interesting to align, not the shadows and such.
 */

/* These two methods should be inverses of each other.  UIKit will call both as part of layout computation.
 They may be overridden to provide arbitrary transforms between frame and alignment rect, though the two methods must be inverses of each other.
 However, the default implementation uses -alignmentRectInsets, so just override that if it's applicable.  It's easier to get right.
 A view that displayed an image with some ornament would typically override these, because the ornamental part of an image would scale up with the size of the frame.
 Set the NSUserDefault UIViewShowAlignmentRects to YES to see alignment rects drawn.
 */
// AutoLayoutå¹¶ä¸ä¼šç›´æ¥æ“ä½œViewçš„Frameï¼Œä½†æ˜¯è§†å›¾çš„alignment rectæ˜¯èµ·ä½œç”¨çš„ã€‚è§†å›¾çš„é»˜è®¤alignmentRectInsetså€¼å°±æ˜¯(0,0,0,0)ã€‚
// æˆ‘ä»¬å¯ä»¥ç®€å•çš„å¯¹å½“å‰Viewè®¾ç½®ç”¨æ¥å¸ƒå±€çš„çŸ©å½¢ï¼Œæ¯”å¦‚ï¼š
// æˆ‘ä»¬æœ‰ä¸€ä¸ªè‡ªå®šä¹‰iconç±»å‹çš„Buttonï¼Œä½†æ˜¯iconçš„å¤§å°æ¯”æˆ‘ä»¬æœŸæœ›ç‚¹å‡»çš„ButtonåŒºåŸŸè¦å°ã€‚è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯ä»¥é‡å†™alignmentRectInsetsï¼ŒæŠŠiconæ”¾åœ¨é€‚å½“çš„ä½ç½®ã€‚
// å¤§å¤šæ•°æƒ…å†µä¸‹é‡å†™alignmentRectInsetsè¿™ä¸ªæ–¹æ³•å¯ä»¥æ»¡è¶³æˆ‘ä»¬çš„å·¥ä½œã€‚å¦‚æœéœ€è¦æ›´åŠ ä¸ªæ€§åŒ–çš„ä¿®æ”¹ï¼Œæˆ‘ä»¬å¯ä»¥é‡å†™alignmentRectForFrameå’ŒframeForAlignmentRectè¿™ä¸¤ä¸ªæ–¹æ³•ã€‚æ¯”å¦‚æˆ‘ä»¬ä¸æƒ³å‡å»è§†å›¾å›ºå®šçš„Insetsï¼Œè€Œæ˜¯éœ€è¦åŸºäºå½“å‰frameä¿®æ”¹alignment rectã€‚åœ¨é‡å†™è¿™ä¸¤ä¸ªæ–¹æ³•æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥ç¡®ä¿æ˜¯äº’ä¸ºå¯é€†çš„ã€‚
- (CGRect)alignmentRectForFrame:(CGRect)frame NS_AVAILABLE_IOS(6_0);
- (CGRect)frameForAlignmentRect:(CGRect)alignmentRect NS_AVAILABLE_IOS(6_0);

/* override this if the alignment rect is obtained from the frame by insetting each edge by a fixed amount.  This is only called by alignmentRectForFrame: and frameForAlignmentRect:.
 */
#if UIKIT_DEFINE_AS_PROPERTIES
@property(nonatomic, readonly) UIEdgeInsets alignmentRectInsets NS_AVAILABLE_IOS(6_0);
#else
- (UIEdgeInsets)alignmentRectInsets NS_AVAILABLE_IOS(6_0);
#endif

/* When you make a constraint on the NSLayoutAttributeBaseline of a view, the system aligns with the bottom of the view returned from this method. A nil return is interpreted as the receiver, and a non-nil return must be in the receiver's subtree.  UIView's implementation returns self.
 */
// æˆ‘ä»¬åœ¨ä½¿ç”¨å¸ƒå±€çº¦æŸä¸­NSLayoutAttributeBaselineå±æ€§æ—¶ï¼Œç³»ç»Ÿä¼šé»˜è®¤è¿”å›å½“å‰è§†å›¾çš„åº•éƒ¨ä½œä¸ºbaselineã€‚æˆ‘ä»¬å¯ä»¥é‡å†™ä¸Šè¿°æ–¹æ³•ï¼Œä½†å¿…é¡»è¿”å›çš„æ˜¯å½“å‰è§†å›¾ä¸­çš„å­è§†å›¾
- (UIView *)viewForBaselineLayout NS_DEPRECATED_IOS(6_0, 9_0, "Override -viewForFirstBaselineLayout or -viewForLastBaselineLayout as appropriate, instead") __TVOS_PROHIBITED;


/* -viewForFirstBaselineLayout is called by the constraints system when interpreting
 the firstBaseline attribute for a view.
 For complex custom UIView subclasses, override this method to return the text-based
 (i.e., UILabel or non-scrollable UITextView) descendant of the receiver whose first baseline
 is appropriate for alignment.
 UIView's implementation returns [self viewForLastBaselineLayout], so if the same
 descendant is appropriate for both first- and last-baseline layout you may override
 just -viewForLastBaselineLayout.
 */
@property(readonly,strong) UIView *viewForFirstBaselineLayout NS_AVAILABLE_IOS(9_0);

/* -viewForLastBaselineLayout is called by the constraints system when interpreting
 the lastBaseline attribute for a view.
 For complex custom UIView subclasses, override this method to return the text-based
 (i.e., UILabel or non-scrollable UITextView) descendant of the receiver whose last baseline
 is appropriate for alignment.
 UIView's implementation returns self.
 */
@property(readonly,strong) UIView *viewForLastBaselineLayout NS_AVAILABLE_IOS(9_0);

/* Override this method to tell the layout system that there is something it doesn't natively understand in this view, and this is how large it intrinsically is.  A typical example would be a single line text field.  The layout system does not understand text - it must just be told that there's something in the view, and that that something will take a certain amount of space if not clipped.
 
 In response, UIKit will set up constraints that specify (1) that the opaque content should not be compressed or clipped, (2) that the view prefers to hug tightly to its content.
 
 A user of a view may need to specify the priority of these constraints.  For example, by default, a push button
 -strongly wants to hug its content in the vertical direction (buttons really ought to be their natural height)
 -weakly hugs its content horizontally (extra side padding between the title and the edge of the bezel is acceptable)
 -strongly resists compressing or clipping content in both directions.
 
 However, you might have a case where you'd prefer to show all the available buttons with truncated text rather than losing some of the buttons. The truncation might only happen in portrait orientation but not in landscape, for example. In that case you'd want to setContentCompressionResistancePriority:forAxis: to (say) UILayoutPriorityDefaultLow for the horizontal axis.
 
 The default 'strong' and 'weak' priorities referred to above are UILayoutPriorityDefaultHigh and UILayoutPriorityDefaultLow.
 
 Note that not all views have an intrinsicContentSize.  UIView's default implementation is to return (UIViewNoIntrinsicMetric, UIViewNoIntrinsicMetric).  The _intrinsic_ content size is concerned only with data that is in the view itself, not in other views. Remember that you can also set constant width or height constraints on any view, and you don't need to override instrinsicContentSize if these dimensions won't be changing with changing view content.
 */
UIKIT_EXTERN const CGFloat UIViewNoIntrinsicMetric NS_AVAILABLE_IOS(6_0); // -1
#if UIKIT_DEFINE_AS_PROPERTIES
@property(nonatomic, readonly) CGSize intrinsicContentSize NS_AVAILABLE_IOS(6_0);
#else
/* é€šè¿‡é‡å†™intrinsicContentSizeå¯ä»¥è®¾ç½®å½“å‰è§†å›¾æ˜¾ç¤ºç‰¹å®šå†…å®¹æ—¶çš„å¤§å°ã€‚æ¯”å¦‚æˆ‘ä»¬è®¾ç½®ä¸€ä¸ªè‡ªå®šä¹‰Viewï¼ŒViewé‡Œé¢åŒ…å«ä¸€ä¸ªLabelæ˜¾ç¤ºæ–‡å­—ï¼Œä¸ºäº†è®¾ç½®å½“å‰Viewåœ¨ä¸åŒSize Classä¸‹å†…å®¹çš„å¤§å°ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·:
- (CGSize)intrinsicContentSize
{
    CGSize size = [label intrinsicContentSize];
    if (self.traitCollection.horizontalSizeClass == UIUserInterfaceSizeClassCompact) {
        size.width += 4.0f;
    } else {
        size.width += 40.0f;
    }
    if (self.traitCollection.verticalSizeClass == UIUserInterfaceSizeClassCompact) {
        size.height += 4.0;
    } else {
        size.height += 40.0;
    }
    return size;
}
 */

- (CGSize)intrinsicContentSize NS_AVAILABLE_IOS(6_0);
#endif
/*
//å½“æœ‰ä»»ä½•ä¼šå½±å“è¿™ä¸ªLabelå†…å®¹å¤§å°çš„äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œæˆ‘ä»¬åº”è¯¥è°ƒç”¨invalidateIntrinsicContentSizeï¼š
label.text = @"content update"
[self invalidateIntrinsicContentSize];
// æˆ–è€…æ¯”å¦‚å½“å‰è§†å›¾Size Classæ”¹å˜çš„æ—¶å€™
- (void)traitCollectionDidChange:(UITraitCollection *)previousTraitCollection
{
    [super traitCollectionDidChange:previousTraitCollection];
    if ((self.traitCollection.verticalSizeClass != previousTraitCollection.verticalSizeClass)
        || (self.traitCollection.horizontalSizeClass != previousTraitCollection.horizontalSizeClass)) {
        [self invalidateIntrinsicContentSize];
    }
}
 */
- (void)invalidateIntrinsicContentSize NS_AVAILABLE_IOS(6_0); // call this when something changes that affects the intrinsicContentSize.  Otherwise UIKit won't notice that it changed.

//è¿”å›æ”¾å¤§çš„è§†å›¾å¸ƒå±€çš„è½´çº¿
- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
//è®¾ç½®æ”¾å¤§çš„è§†å›¾å¸ƒå±€çš„è½´çº¿
- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
//è¿”å›ç¼©å°çš„è§†å›¾å¸ƒå±€çš„è½´çº¿
- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
//è®¾ç½®ç¼©å°çš„è§†å›¾çš„è½´çº¿
- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
/*
 ä¸Šé¢æœ€åå››ä¸ªAPIä¸»è¦æ˜¯é€šè¿‡ä¿®æ”¹æ°´å¹³æˆ–è€…å‚ç›´æ–¹å‘çš„ä¼˜å…ˆçº§æ¥å®ç°è§†å›¾æ˜¯åŸºäºæ°´å¹³ç¼©å°(æ”¾å¤§)è¿˜æ˜¯å‚ç›´ç¼©å°(æ”¾å¤§)ã€‚å½“æˆ‘ä»¬çš„è§†å›¾éœ€è¦æ ¹æ®å†…éƒ¨å†…å®¹è¿›è¡Œè°ƒæ•´å¤§å°æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥ä½¿ç”¨ä¸Šè¿°æ–¹æ³•ä¸ºå½“å‰è§†å›¾è®¾ç½®åˆå§‹å€¼ã€‚è€Œä¸åº”è¯¥é‡å†™è¿™å‡ ä¸ªæ–¹æ³•ã€‚*/
@end

// Size To Fit

UIKIT_EXTERN const CGSize UILayoutFittingCompressedSize NS_AVAILABLE_IOS(6_0);
UIKIT_EXTERN const CGSize UILayoutFittingExpandedSize NS_AVAILABLE_IOS(6_0);

@interface UIView (UIConstraintBasedLayoutFittingSize)
/* The size fitting most closely to targetSize in which the receiver's subtree can be laid out while optimally satisfying the constraints. If you want the smallest possible size, pass UILayoutFittingCompressedSize; for the largest possible size, pass UILayoutFittingExpandedSize.
 Also see the comment for UILayoutPriorityFittingSizeLevel.
 */
// æ»¡è¶³çº¦æŸè§†å›¾çš„å¸ƒå±€å¤§å°
// ä¸‹é¢è¿™ä¸¤ä¸ªAPIå¯ä»¥è·å¾—å½“å‰ä½¿ç”¨AutoLayoutè§†å›¾çš„sizeã€‚å…¶ä¸­targetSizeå¯ä»¥ä¼ å…¥UILayoutFittingCompressedSize(æœ€å°æƒ…å†µä¸‹å¯èƒ½çš„Size)æˆ–è€…UILayoutFittingExpandedSize(æœ€å¤§æƒ…å†µä¸‹å¯èƒ½çš„Size)
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize NS_AVAILABLE_IOS(6_0); // Equivalent to sending -systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority: with UILayoutPriorityFittingSizeLevel for both priorities.
//
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority NS_AVAILABLE_IOS(8_0);
@end

@interface UIView (UILayoutGuideSupport)

/* UILayoutGuide objects owned by the receiver.
 */
@property(nonatomic,readonly,copy) NSArray&lt;__kindof UILayoutGuide *&gt; *layoutGuides NS_AVAILABLE_IOS(9_0);

/* Adds layoutGuide to the receiver, passing the receiver in -setOwningView: to layoutGuide.
 */
- (void)addLayoutGuide:(UILayoutGuide *)layoutGuide NS_AVAILABLE_IOS(9_0);

/* Removes layoutGuide from the receiver, passing nil in -setOwningView: to layoutGuide.
 */
- (void)removeLayoutGuide:(UILayoutGuide *)layoutGuide NS_AVAILABLE_IOS(9_0);
@end

@class NSLayoutXAxisAnchor,NSLayoutYAxisAnchor,NSLayoutDimension;
@interface UIView (UIViewLayoutConstraintCreation)
/* Constraint creation conveniences. See NSLayoutAnchor.h for details.
 */
@property(readonly, strong) NSLayoutXAxisAnchor *leadingAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *trailingAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *leftAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *rightAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *topAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *bottomAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutDimension *widthAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutDimension *heightAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutXAxisAnchor *centerXAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *centerYAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *firstBaselineAnchor NS_AVAILABLE_IOS(9_0);
@property(readonly, strong) NSLayoutYAxisAnchor *lastBaselineAnchor NS_AVAILABLE_IOS(9_0);

@end


// Debugging

/* Everything in this section should be used in debugging only, never in shipping code.  These methods may not exist in the future - no promises.
 */
@interface UIView (UIConstraintBasedLayoutDebugging)

/* This returns a list of all the constraints that are affecting the current location of the receiver.  The constraints do not necessarily involve the receiver, they may affect the frame indirectly.
 Pass UILayoutConstraintAxisHorizontal for the constraints affecting [self center].x and CGRectGetWidth([self bounds]), and UILayoutConstraintAxisVertical for the constraints affecting[self center].y and CGRectGetHeight([self bounds]).
 */
//è·å¾—å®ä½“åœ¨ä¸åŒæ–¹å‘ä¸Šæ‰€æœ‰çš„å¸ƒå±€çº¦æŸ
- (NSArray *)constraintsAffectingLayoutForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

/* If there aren't enough constraints in the system to uniquely determine layout, we say the layout is ambiguous.  For example, if the only constraint in the system was x = y + 100, then there are lots of different possible values for x and y.  This situation is not automatically detected by UIKit, due to performance considerations and details of the algorithm used for layout.
 The symptom of ambiguity is that views sometimes jump from place to place, or possibly are just in the wrong place.
 -hasAmbiguousLayout runs a check for whether there is another center and bounds the receiver could have that could also satisfy the constraints.
 -exerciseAmbiguousLayout does more.  It randomly changes the view layout to a different valid layout.  Making the UI jump back and forth can be helpful for figuring out where you're missing a constraint.
 */
//å¯ä»¥çŸ¥é“å½“å‰è§†å›¾çš„å¸ƒå±€æ˜¯å¦ä¼šæœ‰æ­§ä¹‰ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªç§æœ‰API _autolayoutTraceå¯ä»¥è·å¾—æ•´ä¸ªè§†å›¾æ ‘çš„å­—ç¬¦ä¸²ã€‚
- (BOOL)hasAmbiguousLayout NS_AVAILABLE_IOS(6_0);

//è¿™ä¸ªæ–¹æ³•ä¼šéšæœºæ”¹å˜è§†å›¾çš„layoutåˆ°å¦å¤–ä¸€ä¸ªæœ‰æ•ˆçš„layoutã€‚è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¾ˆæ¸…æ¥šçš„çœ‹åˆ°å“ªä¸€ä¸ªlayoutå¯¼è‡´äº†æ•´ä½“çš„å¸ƒå±€çº¦æŸå‡ºç°äº†é”™è¯¯ï¼Œæˆ–è€…æˆ‘ä»¬åº”è¯¥å¢åŠ æ›´å¤šçš„å¸ƒå±€çº¦æŸã€‚
- (void)exerciseAmbiguityInLayout NS_AVAILABLE_IOS(6_0);

// æˆ‘ä»¬åº”è¯¥è®©ä¸Šé¢çš„å››ä¸ªæ–¹æ³•åªåœ¨DEBUGç¯å¢ƒä¸‹è¢«è°ƒç”¨ã€‚
@end

/* Everything in this section should be used in debugging only, never in shipping code.  These methods may not exist in the future - no promises.
 */
@interface UILayoutGuide (UIConstraintBasedLayoutDebugging)

/* This returns a list of all the constraints that are affecting the current location of the receiver.  The constraints do not necessarily involve the receiver, they may affect the frame indirectly.
 Pass UILayoutConstraintAxisHorizontal for the constraints affecting [self center].x and CGRectGetWidth([self bounds]), and UILayoutConstraintAxisVertical for the constraints affecting[self center].y and CGRectGetHeight([self bounds]).
 */
- (NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraintsAffectingLayoutForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(10_0);

/* If there aren't enough constraints in the system to uniquely determine layout, we say the layout is ambiguous.  For example, if the only constraint in the system was x = y + 100, then there are lots of different possible values for x and y.  This situation is not automatically detected by UIKit, due to performance considerations and details of the algorithm used for layout.
 The symptom of ambiguity is that views sometimes jump from place to place, or possibly are just in the wrong place.
 -hasAmbiguousLayout runs a check for whether there is another center and bounds the receiver could have that could also satisfy the constraints.
 */
#if UIKIT_DEFINE_AS_PROPERTIES
@property(nonatomic, readonly) BOOL hasAmbiguousLayout NS_AVAILABLE_IOS(10_0);
#else
- (BOOL)hasAmbiguousLayout NS_AVAILABLE_IOS(10_0);
#endif
@end

@interface UIView (UIStateRestoration)
//æ ‡ç¤ºæ˜¯å¦æ”¯æŒä¿å­˜,æ¢å¤è§†å›¾çŠ¶æ€ä¿¡æ¯
@property (nonatomic, copy) NSString *restorationIdentifier NS_AVAILABLE_IOS(6_0);
//ä¿å­˜è§†å›¾çŠ¶æ€ç›¸å…³çš„ä¿¡æ¯
- (void) encodeRestorableStateWithCoder:(NSCoder *)coder NS_AVAILABLE_IOS(6_0);
//æ¢å¤å’Œä¿æŒè§†å›¾çŠ¶æ€ç›¸å…³ä¿¡æ¯
- (void) decodeRestorableStateWithCoder:(NSCoder *)coder NS_AVAILABLE_IOS(6_0);
@end

@interface UIView (UISnapshotting)
//å±å¹•å¿«ç…§
/*
 * When requesting a snapshot, 'afterUpdates' defines whether the snapshot is representative of what's currently on screen or if you wish to include any recent changes before taking the snapshot.
 
 If called during layout from a committing transaction, snapshots occurring after the screen updates will include all changes made, regardless of when the snapshot is taken and the changes are made. For example:
 
 - (void)layoutSubviews {
 UIView *snapshot = [self snapshotViewAfterScreenUpdates:YES];
 self.alpha = 0.0;
 }
 
 The snapshot will appear to be empty since the change in alpha will be captured by the snapshot. If you need to animate the view during layout, animate the snapshot instead.
 
 * Creating snapshots from existing snapshots (as a method to duplicate, crop or create a resizable variant) is supported. In cases where many snapshots are needed, creating a snapshot from a common superview and making subsequent snapshots from it can be more performant. Please keep in mind that if 'afterUpdates' is YES, the original snapshot is committed and any changes made to it, not the view originally snapshotted, will be included.
 */
/*
 http://www.csdn123.com/html/topnews201408/58/1858.htm
 http://rralun.blog.163.com/blog/static/1039042962014929111334870/
 http://www.cocoachina.com/ios/20141222/10713.html
 // è¿™ä¸ªæ–¹æ³•èƒ½å¤Ÿé«˜æ•ˆçš„å°†å½“å‰æ˜¾ç¤ºçš„viewæˆªå–æˆä¸€ä¸ªæ–°çš„view.ä½ å¯ä»¥ç”¨è¿™ä¸ªæˆªå–çš„viewç”¨æ¥æ˜¾ç¤º.ä¾‹å¦‚,ä¹Ÿè®¸ä½ åªæƒ³ç”¨ä¸€å¼ æˆªå›¾æ¥åšåŠ¨ç”»,
 æ¯•ç«Ÿç”¨åŸå§‹çš„viewåšåŠ¨ç”»ä»£ä»·å¤ªé«˜.å› ä¸ºæ˜¯æˆªå–äº†å·²ç»å­˜åœ¨çš„å†…å®¹,è¿™ä¸ªæ–¹æ³•åªèƒ½ååº”å‡ºè¿™ä¸ªè¢«æˆªå–çš„viewå½“å‰çš„çŠ¶æ€ä¿¡æ¯,è€Œä¸èƒ½ååº”è¿™ä¸ªè¢«æˆªå–çš„viewä»¥åè¦æ˜¾ç¤ºçš„ä¿¡æ¯.ç„¶è€Œ,ä¸ç®¡æ€ä¹ˆæ ·,è°ƒç”¨è¿™ä¸ªæ–¹æ³•éƒ½ä¼šæ¯”å°†viewåšæˆæˆªå›¾æ¥åŠ è½½æ•ˆç‡æ›´é«˜.*/
- (UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates NS_AVAILABLE_IOS(7_0);
//ç¼©æ”¾ä¸€ä¸ªviewé»˜è®¤æ˜¯ä»ä¸­å¿ƒç‚¹è¿›è¡Œç¼©æ”¾çš„
- (UIView *)resizableSnapshotViewFromRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates withCapInsets:(UIEdgeInsets)capInsets NS_AVAILABLE_IOS(7_0);  // Resizable snapshots will default to stretching the center
// Use this method to render a snapshot of the view hierarchy into the current context. Returns NO if the snapshot is missing image data, YES if the snapshot is complete. Calling this method from layoutSubviews while the current transaction is committing will capture what is currently displayed regardless if afterUpdates is YES.
// å®ƒå…è®¸ä½ æˆªå–ä¸€ä¸ªUIViewæˆ–è€…å…¶å­ç±»ä¸­çš„å†…å®¹
- (BOOL)drawViewHierarchyInRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates NS_AVAILABLE_IOS(7_0);
//å±å¹•å¿«ç…§
@end

</code></pre>

:ET